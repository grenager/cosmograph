{"version":3,"file":"forwardEventsBuilder.js","sources":["../../../../../../../../node_modules/@smui/common/dist/internal/forwardEventsBuilder.js"],"sourcesContent":["// Match old modifiers. (only works on DOM events)\nconst oldModifierRegex = /^[a-z]+(?::(?:preventDefault|stopPropagation|passive|nonpassive|capture|once|self))+$/;\n// Match new modifiers.\nconst newModifierRegex = /^[^$]+(?:\\$(?:preventDefault|stopPropagation|passive|nonpassive|capture|once|self))+$/;\nexport function forwardEventsBuilder(component) {\n    // This is our pseudo $on function. It is defined on component mount.\n    let $on;\n    // This is a list of events bound before mount.\n    let events = [];\n    // And we override the $on function to forward all bound events.\n    component.$on = (fullEventType, callback) => {\n        let eventType = fullEventType;\n        let destructor = () => { };\n        if ($on) {\n            // The event was bound programmatically.\n            destructor = $on(eventType, callback);\n        }\n        else {\n            // The event was bound before mount by Svelte.\n            events.push([eventType, callback]);\n        }\n        const oldModifierMatch = eventType.match(oldModifierRegex);\n        if (oldModifierMatch && console) {\n            console.warn('Event modifiers in SMUI now use \"$\" instead of \":\", so that ' +\n                'all events can be bound with modifiers. Please update your ' +\n                'event binding: ', eventType);\n        }\n        return () => {\n            destructor();\n        };\n    };\n    function bubble(e) {\n        // Internally bubble the event up from Svelte components.\n        const callbacks = component.$$.callbacks[e.type];\n        if (callbacks) {\n            // @ts-ignore\n            callbacks.slice().forEach((fn) => fn.call(this, e));\n        }\n    }\n    return (node) => {\n        const destructors = [];\n        const forwardDestructors = {};\n        // This function is responsible for listening and forwarding\n        // all bound events.\n        $on = (fullEventType, callback) => {\n            let eventType = fullEventType;\n            let handler = callback;\n            // DOM addEventListener options argument.\n            let options = false;\n            const oldModifierMatch = eventType.match(oldModifierRegex);\n            const newModifierMatch = eventType.match(newModifierRegex);\n            const modifierMatch = oldModifierMatch || newModifierMatch;\n            if (eventType.match(/^SMUI:\\w+:/)) {\n                const newEventTypeParts = eventType.split(':');\n                let newEventType = '';\n                for (let i = 0; i < newEventTypeParts.length; i++) {\n                    newEventType +=\n                        i === newEventTypeParts.length - 1\n                            ? ':' + newEventTypeParts[i]\n                            : newEventTypeParts[i]\n                                .split('-')\n                                .map((value) => value.slice(0, 1).toUpperCase() + value.slice(1))\n                                .join('');\n                }\n                console.warn(`The event ${eventType.split('$')[0]} has been renamed to ${newEventType.split('$')[0]}.`);\n                eventType = newEventType;\n            }\n            if (modifierMatch) {\n                // Parse the event modifiers.\n                // Supported modifiers:\n                // - preventDefault\n                // - stopPropagation\n                // - stopImmediatePropagation\n                // - passive\n                // - nonpassive\n                // - capture\n                // - once\n                // - self\n                // - trusted\n                const parts = eventType.split(oldModifierMatch ? ':' : '$');\n                eventType = parts[0];\n                const eventOptions = parts.slice(1).reduce((obj, mod) => {\n                    obj[mod] = true;\n                    return obj;\n                }, {});\n                if (eventOptions.passive) {\n                    options = options || {};\n                    options.passive = true;\n                }\n                if (eventOptions.nonpassive) {\n                    options = options || {};\n                    options.passive = false;\n                }\n                if (eventOptions.capture) {\n                    options = options || {};\n                    options.capture = true;\n                }\n                if (eventOptions.once) {\n                    options = options || {};\n                    options.once = true;\n                }\n                if (eventOptions.preventDefault) {\n                    handler = prevent_default(handler);\n                }\n                if (eventOptions.stopPropagation) {\n                    handler = stop_propagation(handler);\n                }\n                if (eventOptions.stopImmediatePropagation) {\n                    handler = stop_immediate_propagation(handler);\n                }\n                if (eventOptions.self) {\n                    handler = self_event(node, handler);\n                }\n                if (eventOptions.trusted) {\n                    handler = trusted_event(handler);\n                }\n            }\n            // Listen for the event directly, with the given options.\n            const off = listen(node, eventType, handler, options);\n            const destructor = () => {\n                off();\n                const idx = destructors.indexOf(destructor);\n                if (idx > -1) {\n                    destructors.splice(idx, 1);\n                }\n            };\n            destructors.push(destructor);\n            // Forward the event from Svelte.\n            if (!(eventType in forwardDestructors)) {\n                forwardDestructors[eventType] = listen(node, eventType, bubble);\n            }\n            return destructor;\n        };\n        for (let i = 0; i < events.length; i++) {\n            // Listen to all the events added before mount.\n            $on(events[i][0], events[i][1]);\n        }\n        return {\n            destroy: () => {\n                // Remove all event listeners.\n                for (let i = 0; i < destructors.length; i++) {\n                    destructors[i]();\n                }\n                // Remove all event forwarders.\n                for (let entry of Object.entries(forwardDestructors)) {\n                    entry[1]();\n                }\n            },\n        };\n    };\n}\nfunction listen(node, event, handler, options) {\n    node.addEventListener(event, handler, options);\n    return () => node.removeEventListener(event, handler, options);\n}\nfunction prevent_default(fn) {\n    return function (event) {\n        event.preventDefault();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction stop_propagation(fn) {\n    return function (event) {\n        event.stopPropagation();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction stop_immediate_propagation(fn) {\n    return function (event) {\n        event.stopImmediatePropagation();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction self_event(node, fn) {\n    return function (event) {\n        if (event.target !== node) {\n            return;\n        }\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction trusted_event(fn) {\n    return function (event) {\n        if (!event.isTrusted) {\n            return;\n        }\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\n//# sourceMappingURL=forwardEventsBuilder.js.map"],"names":["oldModifierRegex","newModifierRegex","forwardEventsBuilder","component","$on","events","bubble","e","callbacks","$$","type","slice","forEach","fn","call","this","fullEventType","callback","eventType","destructor","push","match","console","warn","node","destructors","forwardDestructors","handler","options","oldModifierMatch","newModifierMatch","modifierMatch","newEventTypeParts","split","newEventType","i","length","map","value","toUpperCase","join","parts","eventOptions","reduce","obj","mod","passive","nonpassive","capture","once","preventDefault","event","stopPropagation","stop_propagation","stopImmediatePropagation","stop_immediate_propagation","self","target","self_event","trusted","isTrusted","trusted_event","off","listen","idx","indexOf","splice","destroy","entry","Object","entries","addEventListener","removeEventListener"],"mappings":"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"}