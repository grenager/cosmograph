import { rectIntersect } from './helper.js';
import { LEFT_RIGHT_PADDING, TOP_BOTTOM_PADDING, DEFAULT_FONT_SIZE } from './variables.js';
import * as s from './css-label-styles.js';
export class CssLabel {
    constructor(container, text) {
        this.element = document.createElement('div');
        this.fontWidthHeightRatio = 0.6;
        this._x = 0;
        this._y = 0;
        this._estimatedWidth = 0;
        this._estimatedHeight = 0;
        this._visible = false;
        this._prevVisible = false;
        this._weight = 0;
        this._customFontSize = DEFAULT_FONT_SIZE;
        this._customColor = undefined;
        this._customOpacity = undefined;
        this._shouldBeShown = false;
        this._text = '';
        this._customPadding = {
            left: LEFT_RIGHT_PADDING,
            top: TOP_BOTTOM_PADDING,
            right: LEFT_RIGHT_PADDING,
            bottom: TOP_BOTTOM_PADDING,
        };
        s.createCssStyles();
        this._container = container;
        this._updateClasses();
        if (text)
            this.setText(text);
        this.resetFontSize();
        this.resetPadding();
    }
    /**
     * Sets the text of the element.
     * @param text - The text to set.
     */
    setText(text) {
        if (this._text !== text) {
            this._text = text;
            this.element.innerHTML = text;
            this._measureText();
        }
    }
    /**
     * Sets the position of the label
     * @param x - The x coordinate of the label
     * @param y - The y coordinate of the label
     */
    setPosition(x, y) {
        this._x = x;
        this._y = y;
    }
    /**
     * Sets the CSS style of the element.
     * If a color, opacity or pointer-events is specified using the `setColor`,
     * `setOpacity` or `setPointerEvents` method, it takes priority over all custom styles.
     * The `fontSize` style will not apply from `setStyle`, and the `transform` style
     * will not apply, as it is used in the draw method to update the label position.
     * @param style - The style to be set.
     */
    setStyle(style) {
        if (this._customStyle !== style) {
            this._customStyle = style;
            this.element.style.cssText = this._customStyle;
            if (this._customColor)
                this.element.style.color = this._customColor;
            if (this._customOpacity)
                this.element.style.opacity = String(this._customOpacity);
            if (this._customPointerEvents)
                this.element.style.pointerEvents = this._customPointerEvents;
            if (this._customFontSize)
                this.element.style.fontSize = `${this._customFontSize}px`;
            if (this._customPadding) {
                const { top, right, bottom, left } = this._customPadding;
                this.element.style.padding = `${top}px ${right}px ${bottom}px ${left}px`;
            }
        }
    }
    /**
     * Sets the class name of the component
     * @param className - The class name to be set
     */
    setClassName(className) {
        if (this._customClassName !== className) {
            this._customClassName = className;
            this._updateClasses();
        }
    }
    /**
     * Sets the font size of the text in pixels.
     * This value cannot be changed through `setStyle` or `setClassName`
     * methods because it is used to measure the width and height of the label.
     * @param fontSize - The font size to set. If not specified, it will use the default value of `14px`.
     */
    setFontSize(fontSize = DEFAULT_FONT_SIZE) {
        if (this._customFontSize !== fontSize) {
            this.element.style.fontSize = `${fontSize}px`;
            this._customFontSize = fontSize;
            this._measureText();
        }
    }
    /**
     * Resets the font size of the element to default value.
     */
    resetFontSize() {
        this.element.style.fontSize = `${DEFAULT_FONT_SIZE}px`;
        this._customFontSize = DEFAULT_FONT_SIZE;
        this._measureText();
    }
    /**
     * Sets the color of the element.
     * This color will rewrite the color from `setStyle` CSS style if specified.
     * @param color - The color to set
     */
    setColor(color) {
        if (this._customColor !== color) {
            this.element.style.color = color;
            this._customColor = color;
        }
    }
    /**
     * Resets the color of the element.
     */
    resetColor() {
        this.element.style.removeProperty('color');
        this._customColor = undefined;
    }
    /**
     * Sets the opacity of the element.
     * This opacity will rewrite the opacity from `setStyle` CSS style if specified.
     * @param opacity - The opacity to set.
     */
    setOpacity(opacity) {
        if (this._customOpacity !== opacity) {
            this.element.style.opacity = String(opacity);
            this._customOpacity = opacity;
        }
    }
    /**
     * Resets the opacity of the element.
     */
    resetOpacity() {
        this.element.style.removeProperty('opacity');
        this._customOpacity = undefined;
    }
    /**
     * Sets the `pointerEvents` property to 'none', 'auto', or 'all'.
     * This `pointerEvents` value will rewrite the opacity from `setStyle` CSS style if specified.
     * @param pointerEvents - The `pointerEvents` value to be set.
     */
    setPointerEvents(pointerEvents) {
        if (this._customPointerEvents !== pointerEvents) {
            this.element.style.pointerEvents = `${pointerEvents}`;
            this._customPointerEvents = pointerEvents;
        }
    }
    /**
     * Resets the pointer-events of the element.
     */
    resetPointerEvents() {
        this.element.style.removeProperty('pointer-events');
        this._customPointerEvents = undefined;
    }
    /**
     * Sets the padding of the element in pixels.
     * This value cannot be changed through `setStyle` or `setClassName`
     * methods because it is used to measure the width and height of the label.
     * @param padding - The padding object with left, top, right and bottom properties.
     * If not specified, it will use the default value of `{ left: 9px, top: 6px, right: 9px, bottom: 6px }`.
     */
    setPadding(padding = {
        left: LEFT_RIGHT_PADDING,
        top: TOP_BOTTOM_PADDING,
        right: LEFT_RIGHT_PADDING,
        bottom: TOP_BOTTOM_PADDING,
    }) {
        if (this._customPadding.left !== padding.left ||
            this._customPadding.top !== padding.top ||
            this._customPadding.right !== padding.right ||
            this._customPadding.bottom !== padding.bottom) {
            this._customPadding = padding;
            this.element.style.padding = `${padding.top}px ${padding.right}px ${padding.bottom}px ${padding.left}px`;
            this._measureText();
        }
    }
    resetPadding() {
        const padding = {
            left: LEFT_RIGHT_PADDING,
            top: TOP_BOTTOM_PADDING,
            right: LEFT_RIGHT_PADDING,
            bottom: TOP_BOTTOM_PADDING,
        };
        this.element.style.padding = `${padding.top}px ${padding.right}px ${padding.bottom}px ${padding.left}px`;
        this._customPadding = padding;
        this._measureText();
    }
    /**
     * Sets the boolean value of whether the element should be forced to shown or not
     * @param shouldBeShown - The boolean value to set
     */
    setForceShow(shouldBeShown) {
        this._shouldBeShown = shouldBeShown;
    }
    /**
     * Gets the boolean value of whether the element should be shown or not.
     * @returns The boolean value of whether the element should be shown or not.
     */
    getForceShow() {
        return this._shouldBeShown;
    }
    /**
     * Draws the element to the container and updates the label's coordinate.
     * The label's coordinate updates using `transform` style. It rewrite
     * the `transform` from `setStyle` CSS style if specified.
     */
    draw() {
        const isVisible = this.getVisibility();
        if (isVisible !== this._prevVisible) {
            if (this._prevVisible === false) {
                this._container.appendChild(this.element);
            }
            else {
                this._container.removeChild(this.element);
            }
            this._updateClasses();
            this._prevVisible = isVisible;
        }
        if (isVisible) {
            this.element.style.transform = `
        translate(-50%, -100%)
        translate3d(${this._x}px, ${this._y}px, 0)
      `;
        }
    }
    overlaps(label) {
        return rectIntersect({
            height: this._estimatedHeight,
            width: this._estimatedWidth,
            x: this._x,
            y: this._y,
        }, {
            height: label._estimatedHeight,
            width: label._estimatedWidth,
            x: label._x,
            y: label._y,
        });
    }
    setVisibility(visible = true) {
        this._visible = visible;
    }
    getVisibility() {
        return this._visible;
    }
    isOnScreen() {
        return this._x > 0 && this._y > 0 && this._x < this._container.offsetWidth && this._y < this._container.offsetHeight;
    }
    setWeight(weight) {
        this._weight = weight;
    }
    getWeight() {
        return this._weight;
    }
    /**
     * Appends the element to the top of the container
     */
    raise() {
        this._container.appendChild(this.element);
    }
    /**
     * Removes the element from the DOM.
     */
    destroy() {
        this.element.remove();
    }
    _updateClasses() {
        const isVisible = this.getVisibility();
        if (isVisible) {
            window.requestAnimationFrame(() => {
                this.element.className = `${s.label} ${this._customClassName || ''}`;
            });
        }
        else {
            this.element.className = `${s.label} ${this._customClassName || ''} ${s.hiddenLabel}`;
        }
    }
    _measureText() {
        const { left, top, right, bottom } = this._customPadding;
        this._estimatedWidth = this._customFontSize * this.fontWidthHeightRatio * this.element.innerHTML.length + left + right;
        this._estimatedHeight = this._customFontSize + top + bottom;
    }
}
//# sourceMappingURL=css-label.js.map