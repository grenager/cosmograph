import { CssLabel } from './css-label.js';
import * as s from './styles.js';
export class LabelRenderer {
    constructor(container, options) {
        this._cssLabels = new Map();
        this._elementToData = new Map();
        s.createCssStyles();
        this._container = container;
        container.addEventListener('click', this._onClick.bind(this));
        this._container.className = s.labelsContainer;
        if (options === null || options === void 0 ? void 0 : options.onLabelClick)
            this._onClickCallback = options.onLabelClick;
        if (options === null || options === void 0 ? void 0 : options.padding)
            this._padding = options.padding;
        if (options === null || options === void 0 ? void 0 : options.pointerEvents)
            this._pointerEvents = options.pointerEvents;
        if (options === null || options === void 0 ? void 0 : options.dispatchWheelEventElement) {
            this._dispatchWheelEventElement = options.dispatchWheelEventElement;
            this._container.addEventListener('wheel', this._onWheel.bind(this));
        }
    }
    setLabels(labels) {
        // Add new labels and take into account existing labels
        const labelsToDelete = new Map(this._cssLabels);
        labels.forEach(label => {
            const { x, y, fontSize, color, text, weight, opacity, shouldBeShown, style, className } = label;
            const exists = this._cssLabels.get(label.id);
            if (exists) {
                labelsToDelete.delete(label.id);
            }
            else {
                const cssLabel = new CssLabel(this._container, label.text);
                this._cssLabels.set(label.id, cssLabel);
                this._elementToData.set(cssLabel.element, label);
            }
            const labelToUpdate = this._cssLabels.get(label.id);
            if (labelToUpdate) {
                labelToUpdate.setText(text);
                labelToUpdate.setPosition(x, y);
                if (style !== undefined)
                    labelToUpdate.setStyle(style);
                if (weight !== undefined)
                    labelToUpdate.setWeight(weight);
                if (fontSize !== undefined)
                    labelToUpdate.setFontSize(fontSize);
                if (color !== undefined)
                    labelToUpdate.setColor(color);
                if (this._padding !== undefined)
                    labelToUpdate.setPadding(this._padding);
                if (this._pointerEvents !== undefined)
                    labelToUpdate.setPointerEvents(this._pointerEvents);
                if (opacity !== undefined)
                    labelToUpdate.setOpacity(opacity);
                if (shouldBeShown !== undefined)
                    labelToUpdate.setForceShow(shouldBeShown);
                if (className !== undefined)
                    labelToUpdate.setClassName(className);
            }
        });
        // Remove labels from points that don't longer exist
        for (const [key] of labelsToDelete) {
            const cssLabel = this._cssLabels.get(key);
            if (cssLabel) {
                this._elementToData.delete(cssLabel.element);
                cssLabel.destroy();
            }
            this._cssLabels.delete(key);
        }
    }
    draw(withIntersection = true) {
        if (withIntersection)
            this._intersectLabels();
        this._cssLabels.forEach(cssLabel => cssLabel.draw());
    }
    show() {
        this._container.className = s.labelsContainer;
    }
    hide() {
        this._container.className = `${s.labelsContainer} ${s.hidden}`;
    }
    destroy() {
        this._container.removeEventListener('click', this._onClick.bind(this));
        this._container.removeEventListener('wheel', this._onWheel.bind(this));
        this._cssLabels.forEach(cssLabel => cssLabel.destroy());
    }
    _onClick(e) {
        var _a;
        const label = this._elementToData.get(e.target);
        if (label) {
            (_a = this._onClickCallback) === null || _a === void 0 ? void 0 : _a.call(this, e, label);
        }
    }
    _onWheel(e) {
        var _a;
        e.preventDefault();
        const newWheelEvent = new WheelEvent('wheel', e);
        (_a = this._dispatchWheelEventElement) === null || _a === void 0 ? void 0 : _a.dispatchEvent(newWheelEvent);
    }
    _intersectLabels() {
        const cssLabels = Array.from(this._cssLabels.values());
        cssLabels.forEach(l => l.setVisibility(l.isOnScreen()));
        for (let i = 0; i < cssLabels.length; i += 1) {
            const label1 = cssLabels[i];
            if (!label1.getVisibility())
                continue;
            for (let j = i + 1; j < cssLabels.length; j += 1) {
                const label2 = cssLabels[j];
                if (!label2.getVisibility())
                    continue;
                const isOverlapping = label1.overlaps(label2);
                if (isOverlapping) {
                    if (label2.getWeight() > label1.getWeight()) {
                        label1.setVisibility(label2.getForceShow() ? false : label1.getForceShow());
                    }
                    else {
                        label2.setVisibility(label1.getForceShow() ? false : label2.getForceShow());
                    }
                    continue;
                }
            }
        }
    }
}
export { CssLabel };
//# sourceMappingURL=index.js.map