// node_modules/crossfilter2/src/array.js
var array8 = arrayUntyped;
var array16 = arrayUntyped;
var array32 = arrayUntyped;
var arrayLengthen = arrayLengthenUntyped;
var arrayWiden = arrayWidenUntyped;
if (typeof Uint8Array !== "undefined") {
  array8 = function(n) {
    return new Uint8Array(n);
  };
  array16 = function(n) {
    return new Uint16Array(n);
  };
  array32 = function(n) {
    return new Uint32Array(n);
  };
  arrayLengthen = function(array, length) {
    if (array.length >= length) return array;
    var copy = new array.constructor(length);
    copy.set(array);
    return copy;
  };
  arrayWiden = function(array, width) {
    var copy;
    switch (width) {
      case 16:
        copy = array16(array.length);
        break;
      case 32:
        copy = array32(array.length);
        break;
      default:
        throw new Error("invalid array width!");
    }
    copy.set(array);
    return copy;
  };
}
function arrayUntyped(n) {
  var array = new Array(n), i = -1;
  while (++i < n) array[i] = 0;
  return array;
}
function arrayLengthenUntyped(array, length) {
  var n = array.length;
  while (n < length) array[n++] = 0;
  return array;
}
function arrayWidenUntyped(array, width) {
  if (width > 32) throw new Error("invalid array width!");
  return array;
}
function bitarray(n) {
  this.length = n;
  this.subarrays = 1;
  this.width = 8;
  this.masks = {
    0: 0
  };
  this[0] = array8(n);
}
bitarray.prototype.lengthen = function(n) {
  var i, len;
  for (i = 0, len = this.subarrays; i < len; ++i) {
    this[i] = arrayLengthen(this[i], n);
  }
  this.length = n;
};
bitarray.prototype.add = function() {
  var m, w, one, i, len;
  for (i = 0, len = this.subarrays; i < len; ++i) {
    m = this.masks[i];
    w = this.width - 32 * i;
    one = (~m & m + 1) >>> 0;
    if (w >= 32 && !one) {
      continue;
    }
    if (w < 32 && one & 1 << w) {
      this[i] = arrayWiden(this[i], w <<= 1);
      this.width = 32 * i + w;
    }
    this.masks[i] |= one;
    return {
      offset: i,
      one
    };
  }
  this[this.subarrays] = array8(this.length);
  this.masks[this.subarrays] = 1;
  this.width += 8;
  return {
    offset: this.subarrays++,
    one: 1
  };
};
bitarray.prototype.copy = function(dest, src) {
  var i, len;
  for (i = 0, len = this.subarrays; i < len; ++i) {
    this[i][dest] = this[i][src];
  }
};
bitarray.prototype.truncate = function(n) {
  var i, len;
  for (i = 0, len = this.subarrays; i < len; ++i) {
    for (var j = this.length - 1; j >= n; j--) {
      this[i][j] = 0;
    }
  }
  this.length = n;
};
bitarray.prototype.zero = function(n) {
  var i, len;
  for (i = 0, len = this.subarrays; i < len; ++i) {
    if (this[i][n]) {
      return false;
    }
  }
  return true;
};
bitarray.prototype.zeroExcept = function(n, offset, zero) {
  var i, len;
  for (i = 0, len = this.subarrays; i < len; ++i) {
    if (i === offset ? this[i][n] & zero : this[i][n]) {
      return false;
    }
  }
  return true;
};
bitarray.prototype.zeroExceptMask = function(n, mask) {
  var i, len;
  for (i = 0, len = this.subarrays; i < len; ++i) {
    if (this[i][n] & mask[i]) {
      return false;
    }
  }
  return true;
};
bitarray.prototype.only = function(n, offset, one) {
  var i, len;
  for (i = 0, len = this.subarrays; i < len; ++i) {
    if (this[i][n] != (i === offset ? one : 0)) {
      return false;
    }
  }
  return true;
};
bitarray.prototype.onlyExcept = function(n, offset, zero, onlyOffset, onlyOne) {
  var mask;
  var i, len;
  for (i = 0, len = this.subarrays; i < len; ++i) {
    mask = this[i][n];
    if (i === offset)
      mask = (mask & zero) >>> 0;
    if (mask != (i === onlyOffset ? onlyOne : 0)) {
      return false;
    }
  }
  return true;
};
var array_default = {
  array8: arrayUntyped,
  array16: arrayUntyped,
  array32: arrayUntyped,
  arrayLengthen: arrayLengthenUntyped,
  arrayWiden: arrayWidenUntyped,
  bitarray
};

// node_modules/crossfilter2/src/filter.js
var filterExact = (bisect2, value) => {
  return function(values) {
    var n = values.length;
    return [bisect2.left(values, value, 0, n), bisect2.right(values, value, 0, n)];
  };
};
var filterRange = (bisect2, range) => {
  var min = range[0], max = range[1];
  return function(values) {
    var n = values.length;
    return [bisect2.left(values, min, 0, n), bisect2.left(values, max, 0, n)];
  };
};
var filterAll = (values) => {
  return [0, values.length];
};
var filter_default = {
  filterExact,
  filterRange,
  filterAll
};

// node_modules/crossfilter2/src/identity.js
var identity_default = (d) => {
  return d;
};

// node_modules/crossfilter2/src/null.js
var null_default = () => {
  return null;
};

// node_modules/crossfilter2/src/zero.js
var zero_default = () => {
  return 0;
};

// node_modules/crossfilter2/src/heap.js
function heap_by(f) {
  function heap(a, lo, hi) {
    var n = hi - lo, i = (n >>> 1) + 1;
    while (--i > 0) sift(a, i, n, lo);
    return a;
  }
  function sort(a, lo, hi) {
    var n = hi - lo, t;
    while (--n > 0) t = a[lo], a[lo] = a[lo + n], a[lo + n] = t, sift(a, 1, n, lo);
    return a;
  }
  function sift(a, i, n, lo) {
    var d = a[--lo + i], x = f(d), child;
    while ((child = i << 1) <= n) {
      if (child < n && f(a[lo + child]) > f(a[lo + child + 1])) child++;
      if (x <= f(a[lo + child])) break;
      a[lo + i] = a[lo + child];
      i = child;
    }
    a[lo + i] = d;
  }
  heap.sort = sort;
  return heap;
}
var h = heap_by(identity_default);
h.by = heap_by;
var heap_default = h;

// node_modules/crossfilter2/src/heapselect.js
function heapselect_by(f) {
  var heap = heap_default.by(f);
  function heapselect(a, lo, hi, k) {
    var queue = new Array(k = Math.min(hi - lo, k)), min, i, d;
    for (i = 0; i < k; ++i) queue[i] = a[lo++];
    heap(queue, 0, k);
    if (lo < hi) {
      min = f(queue[0]);
      do {
        if (f(d = a[lo]) > min) {
          queue[0] = d;
          min = f(heap(queue, 0, k)[0]);
        }
      } while (++lo < hi);
    }
    return queue;
  }
  return heapselect;
}
var h2 = heapselect_by(identity_default);
h2.by = heapselect_by;
var heapselect_default = h2;

// node_modules/crossfilter2/src/bisect.js
function bisect_by(f) {
  function bisectLeft(a, x, lo, hi) {
    while (lo < hi) {
      var mid = lo + hi >>> 1;
      if (f(a[mid]) < x) lo = mid + 1;
      else hi = mid;
    }
    return lo;
  }
  function bisectRight(a, x, lo, hi) {
    while (lo < hi) {
      var mid = lo + hi >>> 1;
      if (x < f(a[mid])) hi = mid;
      else lo = mid + 1;
    }
    return lo;
  }
  bisectRight.right = bisectRight;
  bisectRight.left = bisectLeft;
  return bisectRight;
}
var bisect = bisect_by(identity_default);
bisect.by = bisect_by;
var bisect_default = bisect;

// node_modules/crossfilter2/src/permute.js
var permute_default = (array, index, deep) => {
  for (var i = 0, n = index.length, copy = deep ? JSON.parse(JSON.stringify(array)) : new Array(n); i < n; ++i) {
    copy[i] = array[index[i]];
  }
  return copy;
};

// node_modules/crossfilter2/src/reduce.js
var reduceIncrement = (p) => {
  return p + 1;
};
var reduceDecrement = (p) => {
  return p - 1;
};
var reduceAdd = (f) => {
  return function(p, v) {
    return p + +f(v);
  };
};
var reduceSubtract = (f) => {
  return function(p, v) {
    return p - f(v);
  };
};
var reduce_default = {
  reduceIncrement,
  reduceDecrement,
  reduceAdd,
  reduceSubtract
};

// node_modules/@ranfdev/deepobj/dist/deepobj.m.js
function deepobj_m_default(t, e, i, n, r) {
  for (r in n = (i = i.split(".")).splice(-1, 1), i) e = e[i[r]] = e[i[r]] || {};
  return t(e, n);
}

// node_modules/crossfilter2/src/result.js
var get = (obj, prop) => {
  const value = obj[prop];
  return typeof value === "function" ? value.call(obj) : value;
};
var reg = /\[([\w\d]+)\]/g;
var result_default = (obj, path) => {
  return deepobj_m_default(get, obj, path.replace(reg, ".$1"));
};

// node_modules/crossfilter2/src/index.js
var REMOVED_INDEX = -1;
crossfilter.heap = heap_default;
crossfilter.heapselect = heapselect_default;
crossfilter.bisect = bisect_default;
crossfilter.permute = permute_default;
var src_default = crossfilter;
function crossfilter() {
  var crossfilter2 = {
    add,
    remove: removeData,
    dimension,
    groupAll,
    size,
    all,
    allFiltered,
    onChange,
    isElementFiltered
  };
  var data = [], n = 0, filters, filterListeners = [], dataListeners = [], removeDataListeners = [], callbacks = [];
  filters = new array_default.bitarray(0);
  function add(newData) {
    var n0 = n, n1 = newData.length;
    if (n1) {
      data = data.concat(newData);
      filters.lengthen(n += n1);
      dataListeners.forEach(function(l) {
        l(newData, n0, n1);
      });
      triggerOnChange("dataAdded");
    }
    return crossfilter2;
  }
  function removeData(predicate) {
    var newIndex = new Array(n), removed = [], usePred = typeof predicate === "function", shouldRemove = function(i) {
      return usePred ? predicate(data[i], i) : filters.zero(i);
    };
    for (var index1 = 0, index2 = 0; index1 < n; ++index1) {
      if (shouldRemove(index1)) {
        removed.push(index1);
        newIndex[index1] = REMOVED_INDEX;
      } else {
        newIndex[index1] = index2++;
      }
    }
    filterListeners.forEach(function(l) {
      l(-1, -1, [], removed, true);
    });
    removeDataListeners.forEach(function(l) {
      l(newIndex);
    });
    for (var index3 = 0, index4 = 0; index3 < n; ++index3) {
      if (newIndex[index3] !== REMOVED_INDEX) {
        if (index3 !== index4) filters.copy(index4, index3), data[index4] = data[index3];
        ++index4;
      }
    }
    data.length = n = index4;
    filters.truncate(index4);
    triggerOnChange("dataRemoved");
  }
  function maskForDimensions(dimensions) {
    var n2, d, len, id, mask = Array(filters.subarrays);
    for (n2 = 0; n2 < filters.subarrays; n2++) {
      mask[n2] = ~0;
    }
    for (d = 0, len = dimensions.length; d < len; d++) {
      id = dimensions[d].id();
      mask[id >> 7] &= ~(1 << (id & 63));
    }
    return mask;
  }
  function isElementFiltered(i, ignore_dimensions) {
    var mask = maskForDimensions(ignore_dimensions || []);
    return filters.zeroExceptMask(i, mask);
  }
  function dimension(value, iterable) {
    if (typeof value === "string") {
      var accessorPath = value;
      value = function(d) {
        return result_default(d, accessorPath);
      };
    }
    var dimension2 = {
      filter,
      filterExact: filterExact2,
      filterRange: filterRange2,
      filterFunction,
      filterAll: filterAll2,
      currentFilter,
      hasCurrentFilter,
      top,
      bottom,
      group,
      groupAll: groupAll2,
      dispose,
      remove: dispose,
      // for backwards-compatibility
      accessor: value,
      id: function() {
        return id;
      }
    };
    var one, zero, offset, id, values, index, newValues, newIndex, iterablesIndexCount, iterablesIndexFilterStatus, iterablesEmptyRows = [], sortRange = function(n2) {
      return cr_range(n2).sort(function(A, B) {
        var a = newValues[A], b = newValues[B];
        return a < b ? -1 : a > b ? 1 : A - B;
      });
    }, refilter = filter_default.filterAll, refilterFunction, filterValue, filterValuePresent, indexListeners = [], dimensionGroups = [], lo0 = 0, hi0 = 0, t = 0, k;
    dataListeners.unshift(preAdd);
    dataListeners.push(postAdd);
    removeDataListeners.push(removeData2);
    var tmp = filters.add();
    offset = tmp.offset;
    one = tmp.one;
    zero = ~one;
    id = offset << 7 | Math.log(one) / Math.log(2);
    preAdd(data, 0, n);
    postAdd(data, 0, n);
    function preAdd(newData, n0, n1) {
      var newIterablesIndexCount, newIterablesIndexFilterStatus;
      if (iterable) {
        t = 0;
        j = 0;
        k = [];
        for (var i0 = 0; i0 < newData.length; i0++) {
          for (j = 0, k = value(newData[i0]); j < k.length; j++) {
            t++;
          }
        }
        newValues = [];
        newIterablesIndexCount = cr_range(newData.length);
        newIterablesIndexFilterStatus = cr_index(t, 1);
        var unsortedIndex = cr_range(t);
        for (var l = 0, index1 = 0; index1 < newData.length; index1++) {
          k = value(newData[index1]);
          if (!k.length) {
            newIterablesIndexCount[index1] = 0;
            iterablesEmptyRows.push(index1 + n0);
            continue;
          }
          newIterablesIndexCount[index1] = k.length;
          for (j = 0; j < k.length; j++) {
            newValues.push(k[j]);
            unsortedIndex[l] = index1;
            l++;
          }
        }
        var sortMap = sortRange(t);
        newValues = permute_default(newValues, sortMap);
        newIndex = permute_default(unsortedIndex, sortMap);
      } else {
        newValues = newData.map(value);
        newIndex = sortRange(n1);
        newValues = permute_default(newValues, newIndex);
      }
      var bounds = refilter(newValues), lo1 = bounds[0], hi1 = bounds[1];
      var index2, index3, index4;
      if (iterable) {
        n1 = t;
        if (refilterFunction) {
          for (index2 = 0; index2 < n1; ++index2) {
            if (!refilterFunction(newValues[index2], index2)) {
              if (--newIterablesIndexCount[newIndex[index2]] === 0) {
                filters[offset][newIndex[index2] + n0] |= one;
              }
              newIterablesIndexFilterStatus[index2] = 1;
            }
          }
        } else {
          for (index3 = 0; index3 < lo1; ++index3) {
            if (--newIterablesIndexCount[newIndex[index3]] === 0) {
              filters[offset][newIndex[index3] + n0] |= one;
            }
            newIterablesIndexFilterStatus[index3] = 1;
          }
          for (index4 = hi1; index4 < n1; ++index4) {
            if (--newIterablesIndexCount[newIndex[index4]] === 0) {
              filters[offset][newIndex[index4] + n0] |= one;
            }
            newIterablesIndexFilterStatus[index4] = 1;
          }
        }
      } else {
        if (refilterFunction) {
          for (index2 = 0; index2 < n1; ++index2) {
            if (!refilterFunction(newValues[index2], index2)) {
              filters[offset][newIndex[index2] + n0] |= one;
            }
          }
        } else {
          for (index3 = 0; index3 < lo1; ++index3) {
            filters[offset][newIndex[index3] + n0] |= one;
          }
          for (index4 = hi1; index4 < n1; ++index4) {
            filters[offset][newIndex[index4] + n0] |= one;
          }
        }
      }
      if (!n0) {
        values = newValues;
        index = newIndex;
        iterablesIndexCount = newIterablesIndexCount;
        iterablesIndexFilterStatus = newIterablesIndexFilterStatus;
        lo0 = lo1;
        hi0 = hi1;
        return;
      }
      var oldValues = values, oldIndex = index, oldIterablesIndexFilterStatus = iterablesIndexFilterStatus, old_n0, i1 = 0;
      i0 = 0;
      if (iterable) {
        old_n0 = n0;
        n0 = oldValues.length;
        n1 = t;
      }
      values = iterable ? new Array(n0 + n1) : new Array(n);
      index = iterable ? new Array(n0 + n1) : cr_index(n, n);
      if (iterable) iterablesIndexFilterStatus = cr_index(n0 + n1, 1);
      if (iterable) {
        var oldiiclength = iterablesIndexCount.length;
        iterablesIndexCount = array_default.arrayLengthen(iterablesIndexCount, n);
        for (var j = 0; j + oldiiclength < n; j++) {
          iterablesIndexCount[j + oldiiclength] = newIterablesIndexCount[j];
        }
      }
      var index5 = 0;
      for (; i0 < n0 && i1 < n1; ++index5) {
        if (oldValues[i0] < newValues[i1]) {
          values[index5] = oldValues[i0];
          if (iterable) iterablesIndexFilterStatus[index5] = oldIterablesIndexFilterStatus[i0];
          index[index5] = oldIndex[i0++];
        } else {
          values[index5] = newValues[i1];
          if (iterable) iterablesIndexFilterStatus[index5] = newIterablesIndexFilterStatus[i1];
          index[index5] = newIndex[i1++] + (iterable ? old_n0 : n0);
        }
      }
      for (; i0 < n0; ++i0, ++index5) {
        values[index5] = oldValues[i0];
        if (iterable) iterablesIndexFilterStatus[index5] = oldIterablesIndexFilterStatus[i0];
        index[index5] = oldIndex[i0];
      }
      for (; i1 < n1; ++i1, ++index5) {
        values[index5] = newValues[i1];
        if (iterable) iterablesIndexFilterStatus[index5] = newIterablesIndexFilterStatus[i1];
        index[index5] = newIndex[i1] + (iterable ? old_n0 : n0);
      }
      bounds = refilter(values), lo0 = bounds[0], hi0 = bounds[1];
    }
    function postAdd(newData, n0, n1) {
      indexListeners.forEach(function(l) {
        l(newValues, newIndex, n0, n1);
      });
      newValues = newIndex = null;
    }
    function removeData2(reIndex) {
      if (iterable) {
        for (var i0 = 0, i1 = 0; i0 < iterablesEmptyRows.length; i0++) {
          if (reIndex[iterablesEmptyRows[i0]] !== REMOVED_INDEX) {
            iterablesEmptyRows[i1] = reIndex[iterablesEmptyRows[i0]];
            i1++;
          }
        }
        iterablesEmptyRows.length = i1;
        for (i0 = 0, i1 = 0; i0 < n; i0++) {
          if (reIndex[i0] !== REMOVED_INDEX) {
            if (i1 !== i0) iterablesIndexCount[i1] = iterablesIndexCount[i0];
            i1++;
          }
        }
        iterablesIndexCount = iterablesIndexCount.slice(0, i1);
      }
      var n0 = values.length;
      for (var i = 0, j = 0, oldDataIndex; i < n0; ++i) {
        oldDataIndex = index[i];
        if (reIndex[oldDataIndex] !== REMOVED_INDEX) {
          if (i !== j) values[j] = values[i];
          index[j] = reIndex[oldDataIndex];
          if (iterable) {
            iterablesIndexFilterStatus[j] = iterablesIndexFilterStatus[i];
          }
          ++j;
        }
      }
      values.length = j;
      if (iterable) iterablesIndexFilterStatus = iterablesIndexFilterStatus.slice(0, j);
      while (j < n0) index[j++] = 0;
      var bounds = refilter(values);
      lo0 = bounds[0], hi0 = bounds[1];
    }
    function filterIndexBounds(bounds) {
      var lo1 = bounds[0], hi1 = bounds[1];
      if (refilterFunction) {
        refilterFunction = null;
        filterIndexFunction(function(d, i2) {
          return lo1 <= i2 && i2 < hi1;
        }, bounds[0] === 0 && bounds[1] === values.length);
        lo0 = lo1;
        hi0 = hi1;
        return dimension2;
      }
      var i, j, k2, added = [], removed = [], valueIndexAdded = [], valueIndexRemoved = [];
      if (lo1 < lo0) {
        for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {
          added.push(index[i]);
          valueIndexAdded.push(i);
        }
      } else if (lo1 > lo0) {
        for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {
          removed.push(index[i]);
          valueIndexRemoved.push(i);
        }
      }
      if (hi1 > hi0) {
        for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {
          added.push(index[i]);
          valueIndexAdded.push(i);
        }
      } else if (hi1 < hi0) {
        for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {
          removed.push(index[i]);
          valueIndexRemoved.push(i);
        }
      }
      if (!iterable) {
        for (i = 0; i < added.length; i++) {
          filters[offset][added[i]] ^= one;
        }
        for (i = 0; i < removed.length; i++) {
          filters[offset][removed[i]] ^= one;
        }
      } else {
        var newAdded = [];
        var newRemoved = [];
        for (i = 0; i < added.length; i++) {
          iterablesIndexCount[added[i]]++;
          iterablesIndexFilterStatus[valueIndexAdded[i]] = 0;
          if (iterablesIndexCount[added[i]] === 1) {
            filters[offset][added[i]] ^= one;
            newAdded.push(added[i]);
          }
        }
        for (i = 0; i < removed.length; i++) {
          iterablesIndexCount[removed[i]]--;
          iterablesIndexFilterStatus[valueIndexRemoved[i]] = 1;
          if (iterablesIndexCount[removed[i]] === 0) {
            filters[offset][removed[i]] ^= one;
            newRemoved.push(removed[i]);
          }
        }
        added = newAdded;
        removed = newRemoved;
        if (refilter === filter_default.filterAll) {
          for (i = 0; i < iterablesEmptyRows.length; i++) {
            if (filters[offset][k2 = iterablesEmptyRows[i]] & one) {
              filters[offset][k2] ^= one;
              added.push(k2);
            }
          }
        } else {
          for (i = 0; i < iterablesEmptyRows.length; i++) {
            if (!(filters[offset][k2 = iterablesEmptyRows[i]] & one)) {
              filters[offset][k2] ^= one;
              removed.push(k2);
            }
          }
        }
      }
      lo0 = lo1;
      hi0 = hi1;
      filterListeners.forEach(function(l) {
        l(one, offset, added, removed);
      });
      triggerOnChange("filtered");
      return dimension2;
    }
    function filter(range) {
      return range == null ? filterAll2() : Array.isArray(range) ? filterRange2(range) : typeof range === "function" ? filterFunction(range) : filterExact2(range);
    }
    function filterExact2(value2) {
      filterValue = value2;
      filterValuePresent = true;
      return filterIndexBounds((refilter = filter_default.filterExact(bisect_default, value2))(values));
    }
    function filterRange2(range) {
      filterValue = range;
      filterValuePresent = true;
      return filterIndexBounds((refilter = filter_default.filterRange(bisect_default, range))(values));
    }
    function filterAll2() {
      filterValue = void 0;
      filterValuePresent = false;
      return filterIndexBounds((refilter = filter_default.filterAll)(values));
    }
    function filterFunction(f) {
      filterValue = f;
      filterValuePresent = true;
      refilterFunction = f;
      refilter = filter_default.filterAll;
      filterIndexFunction(f, false);
      var bounds = refilter(values);
      lo0 = bounds[0], hi0 = bounds[1];
      return dimension2;
    }
    function filterIndexFunction(f, filterAll3) {
      var i, k2, x, added = [], removed = [], valueIndexAdded = [], valueIndexRemoved = [], indexLength = values.length;
      if (!iterable) {
        for (i = 0; i < indexLength; ++i) {
          if (!(filters[offset][k2 = index[i]] & one) ^ !!(x = f(values[i], i))) {
            if (x) added.push(k2);
            else removed.push(k2);
          }
        }
      }
      if (iterable) {
        for (i = 0; i < indexLength; ++i) {
          if (f(values[i], i)) {
            added.push(index[i]);
            valueIndexAdded.push(i);
          } else {
            removed.push(index[i]);
            valueIndexRemoved.push(i);
          }
        }
      }
      if (!iterable) {
        for (i = 0; i < added.length; i++) {
          if (filters[offset][added[i]] & one) filters[offset][added[i]] &= zero;
        }
        for (i = 0; i < removed.length; i++) {
          if (!(filters[offset][removed[i]] & one)) filters[offset][removed[i]] |= one;
        }
      } else {
        var newAdded = [];
        var newRemoved = [];
        for (i = 0; i < added.length; i++) {
          if (iterablesIndexFilterStatus[valueIndexAdded[i]] === 1) {
            iterablesIndexCount[added[i]]++;
            iterablesIndexFilterStatus[valueIndexAdded[i]] = 0;
            if (iterablesIndexCount[added[i]] === 1) {
              filters[offset][added[i]] ^= one;
              newAdded.push(added[i]);
            }
          }
        }
        for (i = 0; i < removed.length; i++) {
          if (iterablesIndexFilterStatus[valueIndexRemoved[i]] === 0) {
            iterablesIndexCount[removed[i]]--;
            iterablesIndexFilterStatus[valueIndexRemoved[i]] = 1;
            if (iterablesIndexCount[removed[i]] === 0) {
              filters[offset][removed[i]] ^= one;
              newRemoved.push(removed[i]);
            }
          }
        }
        added = newAdded;
        removed = newRemoved;
        if (filterAll3) {
          for (i = 0; i < iterablesEmptyRows.length; i++) {
            if (filters[offset][k2 = iterablesEmptyRows[i]] & one) {
              filters[offset][k2] ^= one;
              added.push(k2);
            }
          }
        } else {
          for (i = 0; i < iterablesEmptyRows.length; i++) {
            if (!(filters[offset][k2 = iterablesEmptyRows[i]] & one)) {
              filters[offset][k2] ^= one;
              removed.push(k2);
            }
          }
        }
      }
      filterListeners.forEach(function(l) {
        l(one, offset, added, removed);
      });
      triggerOnChange("filtered");
    }
    function currentFilter() {
      return filterValue;
    }
    function hasCurrentFilter() {
      return filterValuePresent;
    }
    function top(k2, top_offset) {
      var array = [], i = hi0, j, toSkip = 0;
      if (top_offset && top_offset > 0) toSkip = top_offset;
      while (--i >= lo0 && k2 > 0) {
        if (filters.zero(j = index[i])) {
          if (toSkip > 0) {
            --toSkip;
          } else {
            array.push(data[j]);
            --k2;
          }
        }
      }
      if (iterable) {
        for (i = 0; i < iterablesEmptyRows.length && k2 > 0; i++) {
          if (filters.zero(j = iterablesEmptyRows[i])) {
            if (toSkip > 0) {
              --toSkip;
            } else {
              array.push(data[j]);
              --k2;
            }
          }
        }
      }
      return array;
    }
    function bottom(k2, bottom_offset) {
      var array = [], i, j, toSkip = 0;
      if (bottom_offset && bottom_offset > 0) toSkip = bottom_offset;
      if (iterable) {
        for (i = 0; i < iterablesEmptyRows.length && k2 > 0; i++) {
          if (filters.zero(j = iterablesEmptyRows[i])) {
            if (toSkip > 0) {
              --toSkip;
            } else {
              array.push(data[j]);
              --k2;
            }
          }
        }
      }
      i = lo0;
      while (i < hi0 && k2 > 0) {
        if (filters.zero(j = index[i])) {
          if (toSkip > 0) {
            --toSkip;
          } else {
            array.push(data[j]);
            --k2;
          }
        }
        i++;
      }
      return array;
    }
    function group(key) {
      var group2 = {
        top: top2,
        all: all2,
        reduce,
        reduceCount,
        reduceSum,
        order,
        orderNatural,
        size: size2,
        dispose: dispose2,
        remove: dispose2
        // for backwards-compatibility
      };
      dimensionGroups.push(group2);
      var groups, groupIndex, groupWidth = 8, groupCapacity = capacity(groupWidth), k2 = 0, select, heap, reduceAdd2, reduceRemove, reduceInitial, update = null_default, reset = null_default, resetNeeded = true, groupAll3 = key === null_default, n0old;
      if (arguments.length < 1) key = identity_default;
      filterListeners.push(update);
      indexListeners.push(add2);
      removeDataListeners.push(removeData3);
      add2(values, index, 0, n);
      function add2(newValues2, newIndex2, n0, n1) {
        if (iterable) {
          n0old = n0;
          n0 = values.length - newValues2.length;
          n1 = newValues2.length;
        }
        var oldGroups = groups, reIndex = iterable ? [] : cr_index(k2, groupCapacity), add3 = reduceAdd2, remove = reduceRemove, initial = reduceInitial, k0 = k2, i0 = 0, i1 = 0, j, g0, x0, x1, g, x;
        if (resetNeeded) add3 = initial = null_default;
        if (resetNeeded) remove = initial = null_default;
        groups = new Array(k2), k2 = 0;
        if (iterable) {
          groupIndex = k0 ? groupIndex : [];
        } else {
          groupIndex = k0 > 1 ? array_default.arrayLengthen(groupIndex, n) : cr_index(n, groupCapacity);
        }
        if (k0) x0 = (g0 = oldGroups[0]).key;
        while (i1 < n1 && !((x1 = key(newValues2[i1])) >= x1)) ++i1;
        while (i1 < n1) {
          if (g0 && x0 <= x1) {
            g = g0, x = x0;
            reIndex[i0] = k2;
            g0 = oldGroups[++i0];
            if (g0) x0 = g0.key;
          } else {
            g = { key: x1, value: initial() }, x = x1;
          }
          groups[k2] = g;
          while (x1 <= x) {
            j = newIndex2[i1] + (iterable ? n0old : n0);
            if (iterable) {
              if (groupIndex[j]) {
                groupIndex[j].push(k2);
              } else {
                groupIndex[j] = [k2];
              }
            } else {
              groupIndex[j] = k2;
            }
            g.value = add3(g.value, data[j], true);
            if (!filters.zeroExcept(j, offset, zero)) g.value = remove(g.value, data[j], false);
            if (++i1 >= n1) break;
            x1 = key(newValues2[i1]);
          }
          groupIncrement();
        }
        while (i0 < k0) {
          groups[reIndex[i0] = k2] = oldGroups[i0++];
          groupIncrement();
        }
        if (iterable) {
          for (var index1 = 0; index1 < n; index1++) {
            if (!groupIndex[index1]) {
              groupIndex[index1] = [];
            }
          }
        }
        if (k2 > i0) {
          if (iterable) {
            for (i0 = 0; i0 < n0old; ++i0) {
              for (index1 = 0; index1 < groupIndex[i0].length; index1++) {
                groupIndex[i0][index1] = reIndex[groupIndex[i0][index1]];
              }
            }
          } else {
            for (i0 = 0; i0 < n0; ++i0) {
              groupIndex[i0] = reIndex[groupIndex[i0]];
            }
          }
        }
        j = filterListeners.indexOf(update);
        if (k2 > 1 || iterable) {
          update = updateMany;
          reset = resetMany;
        } else {
          if (!k2 && groupAll3) {
            k2 = 1;
            groups = [{ key: null, value: initial() }];
          }
          if (k2 === 1) {
            update = updateOne;
            reset = resetOne;
          } else {
            update = null_default;
            reset = null_default;
          }
          groupIndex = null;
        }
        filterListeners[j] = update;
        function groupIncrement() {
          if (iterable) {
            k2++;
            return;
          }
          if (++k2 === groupCapacity) {
            reIndex = array_default.arrayWiden(reIndex, groupWidth <<= 1);
            groupIndex = array_default.arrayWiden(groupIndex, groupWidth);
            groupCapacity = capacity(groupWidth);
          }
        }
      }
      function removeData3(reIndex) {
        if (k2 > 1 || iterable) {
          var oldK = k2, oldGroups = groups, seenGroups = cr_index(oldK, oldK), i, i0, j;
          if (!iterable) {
            for (i = 0, j = 0; i < n; ++i) {
              if (reIndex[i] !== REMOVED_INDEX) {
                seenGroups[groupIndex[j] = groupIndex[i]] = 1;
                ++j;
              }
            }
          } else {
            for (i = 0, j = 0; i < n; ++i) {
              if (reIndex[i] !== REMOVED_INDEX) {
                groupIndex[j] = groupIndex[i];
                for (i0 = 0; i0 < groupIndex[j].length; i0++) {
                  seenGroups[groupIndex[j][i0]] = 1;
                }
                ++j;
              }
            }
            groupIndex = groupIndex.slice(0, j);
          }
          groups = [], k2 = 0;
          for (i = 0; i < oldK; ++i) {
            if (seenGroups[i]) {
              seenGroups[i] = k2++;
              groups.push(oldGroups[i]);
            }
          }
          if (k2 > 1 || iterable) {
            if (!iterable) {
              for (i = 0; i < j; ++i) groupIndex[i] = seenGroups[groupIndex[i]];
            } else {
              for (i = 0; i < j; ++i) {
                for (i0 = 0; i0 < groupIndex[i].length; ++i0) {
                  groupIndex[i][i0] = seenGroups[groupIndex[i][i0]];
                }
              }
            }
          } else {
            groupIndex = null;
          }
          filterListeners[filterListeners.indexOf(update)] = k2 > 1 || iterable ? (reset = resetMany, update = updateMany) : k2 === 1 ? (reset = resetOne, update = updateOne) : reset = update = null_default;
        } else if (k2 === 1) {
          if (groupAll3) return;
          for (var index3 = 0; index3 < n; ++index3) if (reIndex[index3] !== REMOVED_INDEX) return;
          groups = [], k2 = 0;
          filterListeners[filterListeners.indexOf(update)] = update = reset = null_default;
        }
      }
      function updateMany(filterOne, filterOffset, added, removed, notFilter) {
        if (filterOne === one && filterOffset === offset || resetNeeded) return;
        var i, j, k3, n2, g;
        if (iterable) {
          for (i = 0, n2 = added.length; i < n2; ++i) {
            if (filters.zeroExcept(k3 = added[i], offset, zero)) {
              for (j = 0; j < groupIndex[k3].length; j++) {
                g = groups[groupIndex[k3][j]];
                g.value = reduceAdd2(g.value, data[k3], false, j);
              }
            }
          }
          for (i = 0, n2 = removed.length; i < n2; ++i) {
            if (filters.onlyExcept(k3 = removed[i], offset, zero, filterOffset, filterOne)) {
              for (j = 0; j < groupIndex[k3].length; j++) {
                g = groups[groupIndex[k3][j]];
                g.value = reduceRemove(g.value, data[k3], notFilter, j);
              }
            }
          }
          return;
        }
        for (i = 0, n2 = added.length; i < n2; ++i) {
          if (filters.zeroExcept(k3 = added[i], offset, zero)) {
            g = groups[groupIndex[k3]];
            g.value = reduceAdd2(g.value, data[k3], false);
          }
        }
        for (i = 0, n2 = removed.length; i < n2; ++i) {
          if (filters.onlyExcept(k3 = removed[i], offset, zero, filterOffset, filterOne)) {
            g = groups[groupIndex[k3]];
            g.value = reduceRemove(g.value, data[k3], notFilter);
          }
        }
      }
      function updateOne(filterOne, filterOffset, added, removed, notFilter) {
        if (filterOne === one && filterOffset === offset || resetNeeded) return;
        var i, k3, n2, g = groups[0];
        for (i = 0, n2 = added.length; i < n2; ++i) {
          if (filters.zeroExcept(k3 = added[i], offset, zero)) {
            g.value = reduceAdd2(g.value, data[k3], false);
          }
        }
        for (i = 0, n2 = removed.length; i < n2; ++i) {
          if (filters.onlyExcept(k3 = removed[i], offset, zero, filterOffset, filterOne)) {
            g.value = reduceRemove(g.value, data[k3], notFilter);
          }
        }
      }
      function resetMany() {
        var i, j, g;
        for (i = 0; i < k2; ++i) {
          groups[i].value = reduceInitial();
        }
        if (iterable) {
          for (i = 0; i < n; ++i) {
            for (j = 0; j < groupIndex[i].length; j++) {
              g = groups[groupIndex[i][j]];
              g.value = reduceAdd2(g.value, data[i], true, j);
            }
          }
          for (i = 0; i < n; ++i) {
            if (!filters.zeroExcept(i, offset, zero)) {
              for (j = 0; j < groupIndex[i].length; j++) {
                g = groups[groupIndex[i][j]];
                g.value = reduceRemove(g.value, data[i], false, j);
              }
            }
          }
          return;
        }
        for (i = 0; i < n; ++i) {
          g = groups[groupIndex[i]];
          g.value = reduceAdd2(g.value, data[i], true);
        }
        for (i = 0; i < n; ++i) {
          if (!filters.zeroExcept(i, offset, zero)) {
            g = groups[groupIndex[i]];
            g.value = reduceRemove(g.value, data[i], false);
          }
        }
      }
      function resetOne() {
        var i, g = groups[0];
        g.value = reduceInitial();
        for (i = 0; i < n; ++i) {
          g.value = reduceAdd2(g.value, data[i], true);
        }
        for (i = 0; i < n; ++i) {
          if (!filters.zeroExcept(i, offset, zero)) {
            g.value = reduceRemove(g.value, data[i], false);
          }
        }
      }
      function all2() {
        if (resetNeeded) reset(), resetNeeded = false;
        return groups;
      }
      function top2(k3) {
        var top3 = select(all2(), 0, groups.length, k3);
        return heap.sort(top3, 0, top3.length);
      }
      function reduce(add3, remove, initial) {
        reduceAdd2 = add3;
        reduceRemove = remove;
        reduceInitial = initial;
        resetNeeded = true;
        return group2;
      }
      function reduceCount() {
        return reduce(reduce_default.reduceIncrement, reduce_default.reduceDecrement, zero_default);
      }
      function reduceSum(value2) {
        return reduce(reduce_default.reduceAdd(value2), reduce_default.reduceSubtract(value2), zero_default);
      }
      function order(value2) {
        select = heapselect_default.by(valueOf);
        heap = heap_default.by(valueOf);
        function valueOf(d) {
          return value2(d.value);
        }
        return group2;
      }
      function orderNatural() {
        return order(identity_default);
      }
      function size2() {
        return k2;
      }
      function dispose2() {
        var i = filterListeners.indexOf(update);
        if (i >= 0) filterListeners.splice(i, 1);
        i = indexListeners.indexOf(add2);
        if (i >= 0) indexListeners.splice(i, 1);
        i = removeDataListeners.indexOf(removeData3);
        if (i >= 0) removeDataListeners.splice(i, 1);
        i = dimensionGroups.indexOf(group2);
        if (i >= 0) dimensionGroups.splice(i, 1);
        return group2;
      }
      return reduceCount().orderNatural();
    }
    function groupAll2() {
      var g = group(null_default), all2 = g.all;
      delete g.all;
      delete g.top;
      delete g.order;
      delete g.orderNatural;
      delete g.size;
      g.value = function() {
        return all2()[0].value;
      };
      return g;
    }
    function dispose() {
      dimensionGroups.forEach(function(group2) {
        group2.dispose();
      });
      var i = dataListeners.indexOf(preAdd);
      if (i >= 0) dataListeners.splice(i, 1);
      i = dataListeners.indexOf(postAdd);
      if (i >= 0) dataListeners.splice(i, 1);
      i = removeDataListeners.indexOf(removeData2);
      if (i >= 0) removeDataListeners.splice(i, 1);
      filters.masks[offset] &= zero;
      return filterAll2();
    }
    return dimension2;
  }
  function groupAll() {
    var group = {
      reduce,
      reduceCount,
      reduceSum,
      value,
      dispose,
      remove: dispose
      // for backwards-compatibility
    };
    var reduceValue, reduceAdd2, reduceRemove, reduceInitial, resetNeeded = true;
    filterListeners.push(update);
    dataListeners.push(add2);
    add2(data, 0, n);
    function add2(newData, n0) {
      var i;
      if (resetNeeded) return;
      for (i = n0; i < n; ++i) {
        reduceValue = reduceAdd2(reduceValue, data[i], true);
        if (!filters.zero(i)) {
          reduceValue = reduceRemove(reduceValue, data[i], false);
        }
      }
    }
    function update(filterOne, filterOffset, added, removed, notFilter) {
      var i, k, n2;
      if (resetNeeded) return;
      for (i = 0, n2 = added.length; i < n2; ++i) {
        if (filters.zero(k = added[i])) {
          reduceValue = reduceAdd2(reduceValue, data[k], notFilter);
        }
      }
      for (i = 0, n2 = removed.length; i < n2; ++i) {
        if (filters.only(k = removed[i], filterOffset, filterOne)) {
          reduceValue = reduceRemove(reduceValue, data[k], notFilter);
        }
      }
    }
    function reset() {
      var i;
      reduceValue = reduceInitial();
      for (i = 0; i < n; ++i) {
        reduceValue = reduceAdd2(reduceValue, data[i], true);
        if (!filters.zero(i)) {
          reduceValue = reduceRemove(reduceValue, data[i], false);
        }
      }
    }
    function reduce(add3, remove, initial) {
      reduceAdd2 = add3;
      reduceRemove = remove;
      reduceInitial = initial;
      resetNeeded = true;
      return group;
    }
    function reduceCount() {
      return reduce(reduce_default.reduceIncrement, reduce_default.reduceDecrement, zero_default);
    }
    function reduceSum(value2) {
      return reduce(reduce_default.reduceAdd(value2), reduce_default.reduceSubtract(value2), zero_default);
    }
    function value() {
      if (resetNeeded) reset(), resetNeeded = false;
      return reduceValue;
    }
    function dispose() {
      var i = filterListeners.indexOf(update);
      if (i >= 0) filterListeners.splice(i, 1);
      i = dataListeners.indexOf(add2);
      if (i >= 0) dataListeners.splice(i, 1);
      return group;
    }
    return reduceCount();
  }
  function size() {
    return n;
  }
  function all() {
    return data;
  }
  function allFiltered(ignore_dimensions) {
    var array = [], i = 0, mask = maskForDimensions(ignore_dimensions || []);
    for (i = 0; i < n; i++) {
      if (filters.zeroExceptMask(i, mask)) {
        array.push(data[i]);
      }
    }
    return array;
  }
  function onChange(cb) {
    if (typeof cb !== "function") {
      console.warn("onChange callback parameter must be a function!");
      return;
    }
    callbacks.push(cb);
    return function() {
      callbacks.splice(callbacks.indexOf(cb), 1);
    };
  }
  function triggerOnChange(eventName) {
    for (var i = 0; i < callbacks.length; i++) {
      callbacks[i](eventName);
    }
  }
  return arguments.length ? add(arguments[0]) : crossfilter2;
}
function cr_index(n, m) {
  return (m < 257 ? array_default.array8 : m < 65537 ? array_default.array16 : array_default.array32)(n);
}
function cr_range(n) {
  var range = cr_index(n, n);
  for (var i = -1; ++i < n; ) range[i] = i;
  return range;
}
function capacity(w) {
  return w === 8 ? 256 : w === 16 ? 65536 : 4294967296;
}

export {
  src_default
};
//# sourceMappingURL=chunk-YD743BG4.js.map
