// node_modules/@interacta/css-labels/dist/helper.js
function rectIntersect(rect1, rect2) {
  const [left1, top1, right1, bottom1] = [rect1.x, rect1.y + rect1.height, rect1.x + rect1.width, rect1.y];
  const [left2, top2, right2, bottom2] = [rect2.x, rect2.y + rect2.height, rect2.x + rect2.width, rect2.y];
  return !(top1 < bottom2 || top2 < bottom1 || right1 < left2 || right2 < left1);
}

// node_modules/@interacta/css-labels/dist/variables.js
var TOP_BOTTOM_PADDING = 6;
var LEFT_RIGHT_PADDING = 9;
var DEFAULT_FONT_SIZE = 14;

// node_modules/@interacta/css-labels/dist/css-label-styles.js
var label = "css-label--label";
var hiddenLabel = "css-label--hidden";
var globalCssLabelStyles;
var createCssStyles = () => {
  if (globalCssLabelStyles)
    return;
  globalCssLabelStyles = document.createElement("style");
  globalCssLabelStyles.innerHTML = `
  :root {
    --css-label-background-color: #1e2428;
    --css-label-brightness: brightness(150%);
  }

  .${label} {
    position: absolute;
    top: 0;
    left: 0;

    font-weight: 500;
    cursor: pointer;
    
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

    filter: var(--css-label-brightness);
    pointer-events: none;
    background-color: var(--css-label-background-color);
    font-weight: 700;
    border-radius: 6px;
    
    transition: opacity 600ms;
    opacity: 1;
  }

  .${hiddenLabel} {
    opacity: 0 !important;
  }
`;
  const firstStyleTagInHead = document.head.getElementsByTagName("style")[0];
  if (firstStyleTagInHead)
    document.head.insertBefore(globalCssLabelStyles, firstStyleTagInHead);
  else
    document.head.appendChild(globalCssLabelStyles);
};

// node_modules/@interacta/css-labels/dist/css-label.js
var CssLabel = class {
  constructor(container, text) {
    this.element = document.createElement("div");
    this.fontWidthHeightRatio = 0.6;
    this._x = 0;
    this._y = 0;
    this._estimatedWidth = 0;
    this._estimatedHeight = 0;
    this._visible = false;
    this._prevVisible = false;
    this._weight = 0;
    this._customFontSize = DEFAULT_FONT_SIZE;
    this._customColor = void 0;
    this._customOpacity = void 0;
    this._shouldBeShown = false;
    this._text = "";
    this._customPadding = {
      left: LEFT_RIGHT_PADDING,
      top: TOP_BOTTOM_PADDING,
      right: LEFT_RIGHT_PADDING,
      bottom: TOP_BOTTOM_PADDING
    };
    createCssStyles();
    this._container = container;
    this._updateClasses();
    if (text)
      this.setText(text);
    this.resetFontSize();
    this.resetPadding();
  }
  /**
   * Sets the text of the element.
   * @param text - The text to set.
   */
  setText(text) {
    if (this._text !== text) {
      this._text = text;
      this.element.innerHTML = text;
      this._measureText();
    }
  }
  /**
   * Sets the position of the label
   * @param x - The x coordinate of the label
   * @param y - The y coordinate of the label
   */
  setPosition(x, y) {
    this._x = x;
    this._y = y;
  }
  /**
   * Sets the CSS style of the element.
   * If a color, opacity or pointer-events is specified using the `setColor`,
   * `setOpacity` or `setPointerEvents` method, it takes priority over all custom styles.
   * The `fontSize` style will not apply from `setStyle`, and the `transform` style
   * will not apply, as it is used in the draw method to update the label position.
   * @param style - The style to be set.
   */
  setStyle(style) {
    if (this._customStyle !== style) {
      this._customStyle = style;
      this.element.style.cssText = this._customStyle;
      if (this._customColor)
        this.element.style.color = this._customColor;
      if (this._customOpacity)
        this.element.style.opacity = String(this._customOpacity);
      if (this._customPointerEvents)
        this.element.style.pointerEvents = this._customPointerEvents;
      if (this._customFontSize)
        this.element.style.fontSize = `${this._customFontSize}px`;
      if (this._customPadding) {
        const { top, right, bottom, left } = this._customPadding;
        this.element.style.padding = `${top}px ${right}px ${bottom}px ${left}px`;
      }
    }
  }
  /**
   * Sets the class name of the component
   * @param className - The class name to be set
   */
  setClassName(className) {
    if (this._customClassName !== className) {
      this._customClassName = className;
      this._updateClasses();
    }
  }
  /**
   * Sets the font size of the text in pixels.
   * This value cannot be changed through `setStyle` or `setClassName`
   * methods because it is used to measure the width and height of the label.
   * @param fontSize - The font size to set. If not specified, it will use the default value of `14px`.
   */
  setFontSize(fontSize = DEFAULT_FONT_SIZE) {
    if (this._customFontSize !== fontSize) {
      this.element.style.fontSize = `${fontSize}px`;
      this._customFontSize = fontSize;
      this._measureText();
    }
  }
  /**
   * Resets the font size of the element to default value.
   */
  resetFontSize() {
    this.element.style.fontSize = `${DEFAULT_FONT_SIZE}px`;
    this._customFontSize = DEFAULT_FONT_SIZE;
    this._measureText();
  }
  /**
   * Sets the color of the element.
   * This color will rewrite the color from `setStyle` CSS style if specified.
   * @param color - The color to set
   */
  setColor(color) {
    if (this._customColor !== color) {
      this.element.style.color = color;
      this._customColor = color;
    }
  }
  /**
   * Resets the color of the element.
   */
  resetColor() {
    this.element.style.removeProperty("color");
    this._customColor = void 0;
  }
  /**
   * Sets the opacity of the element.
   * This opacity will rewrite the opacity from `setStyle` CSS style if specified.
   * @param opacity - The opacity to set.
   */
  setOpacity(opacity) {
    if (this._customOpacity !== opacity) {
      this.element.style.opacity = String(opacity);
      this._customOpacity = opacity;
    }
  }
  /**
   * Resets the opacity of the element.
   */
  resetOpacity() {
    this.element.style.removeProperty("opacity");
    this._customOpacity = void 0;
  }
  /**
   * Sets the `pointerEvents` property to 'none', 'auto', or 'all'.
   * This `pointerEvents` value will rewrite the opacity from `setStyle` CSS style if specified.
   * @param pointerEvents - The `pointerEvents` value to be set.
   */
  setPointerEvents(pointerEvents) {
    if (this._customPointerEvents !== pointerEvents) {
      this.element.style.pointerEvents = `${pointerEvents}`;
      this._customPointerEvents = pointerEvents;
    }
  }
  /**
   * Resets the pointer-events of the element.
   */
  resetPointerEvents() {
    this.element.style.removeProperty("pointer-events");
    this._customPointerEvents = void 0;
  }
  /**
   * Sets the padding of the element in pixels.
   * This value cannot be changed through `setStyle` or `setClassName`
   * methods because it is used to measure the width and height of the label.
   * @param padding - The padding object with left, top, right and bottom properties.
   * If not specified, it will use the default value of `{ left: 9px, top: 6px, right: 9px, bottom: 6px }`.
   */
  setPadding(padding = {
    left: LEFT_RIGHT_PADDING,
    top: TOP_BOTTOM_PADDING,
    right: LEFT_RIGHT_PADDING,
    bottom: TOP_BOTTOM_PADDING
  }) {
    if (this._customPadding.left !== padding.left || this._customPadding.top !== padding.top || this._customPadding.right !== padding.right || this._customPadding.bottom !== padding.bottom) {
      this._customPadding = padding;
      this.element.style.padding = `${padding.top}px ${padding.right}px ${padding.bottom}px ${padding.left}px`;
      this._measureText();
    }
  }
  resetPadding() {
    const padding = {
      left: LEFT_RIGHT_PADDING,
      top: TOP_BOTTOM_PADDING,
      right: LEFT_RIGHT_PADDING,
      bottom: TOP_BOTTOM_PADDING
    };
    this.element.style.padding = `${padding.top}px ${padding.right}px ${padding.bottom}px ${padding.left}px`;
    this._customPadding = padding;
    this._measureText();
  }
  /**
   * Sets the boolean value of whether the element should be forced to shown or not
   * @param shouldBeShown - The boolean value to set
   */
  setForceShow(shouldBeShown) {
    this._shouldBeShown = shouldBeShown;
  }
  /**
   * Gets the boolean value of whether the element should be shown or not.
   * @returns The boolean value of whether the element should be shown or not.
   */
  getForceShow() {
    return this._shouldBeShown;
  }
  /**
   * Draws the element to the container and updates the label's coordinate.
   * The label's coordinate updates using `transform` style. It rewrite
   * the `transform` from `setStyle` CSS style if specified.
   */
  draw() {
    const isVisible = this.getVisibility();
    if (isVisible !== this._prevVisible) {
      if (this._prevVisible === false) {
        this._container.appendChild(this.element);
      } else {
        this._container.removeChild(this.element);
      }
      this._updateClasses();
      this._prevVisible = isVisible;
    }
    if (isVisible) {
      this.element.style.transform = `
        translate(-50%, -100%)
        translate3d(${this._x}px, ${this._y}px, 0)
      `;
    }
  }
  overlaps(label2) {
    return rectIntersect({
      height: this._estimatedHeight,
      width: this._estimatedWidth,
      x: this._x,
      y: this._y
    }, {
      height: label2._estimatedHeight,
      width: label2._estimatedWidth,
      x: label2._x,
      y: label2._y
    });
  }
  setVisibility(visible = true) {
    this._visible = visible;
  }
  getVisibility() {
    return this._visible;
  }
  isOnScreen() {
    return this._x > 0 && this._y > 0 && this._x < this._container.offsetWidth && this._y < this._container.offsetHeight;
  }
  setWeight(weight) {
    this._weight = weight;
  }
  getWeight() {
    return this._weight;
  }
  /**
   * Appends the element to the top of the container
   */
  raise() {
    this._container.appendChild(this.element);
  }
  /**
   * Removes the element from the DOM.
   */
  destroy() {
    this.element.remove();
  }
  _updateClasses() {
    const isVisible = this.getVisibility();
    if (isVisible) {
      window.requestAnimationFrame(() => {
        this.element.className = `${label} ${this._customClassName || ""}`;
      });
    } else {
      this.element.className = `${label} ${this._customClassName || ""} ${hiddenLabel}`;
    }
  }
  _measureText() {
    const { left, top, right, bottom } = this._customPadding;
    this._estimatedWidth = this._customFontSize * this.fontWidthHeightRatio * this.element.innerHTML.length + left + right;
    this._estimatedHeight = this._customFontSize + top + bottom;
  }
};

// node_modules/@interacta/css-labels/dist/styles.js
var labelsContainer = "css-label--labels-container";
var hidden = "css-label--labels-container-hidden";
var globalContainerStyle;
var createCssStyles2 = () => {
  if (globalContainerStyle)
    return;
  globalContainerStyle = document.createElement("style");
  globalContainerStyle.innerHTML = `
  .${labelsContainer} {
    transition: opacity 100ms;
    position: absolute;
    width: 100%;
    height: 100%;
    overflow: hidden;
    top: 0%;
    pointer-events: none;
    opacity: 1;
  }
  .${hidden} {
    opacity: 0;

    div {
      pointer-events: none;
    }
  }
`;
  const firstStyleTagInHead = document.head.getElementsByTagName("style")[0];
  if (firstStyleTagInHead)
    document.head.insertBefore(globalContainerStyle, firstStyleTagInHead);
  else
    document.head.appendChild(globalContainerStyle);
};

// node_modules/@interacta/css-labels/dist/index.js
var LabelRenderer = class {
  constructor(container, options) {
    this._cssLabels = /* @__PURE__ */ new Map();
    this._elementToData = /* @__PURE__ */ new Map();
    createCssStyles2();
    this._container = container;
    container.addEventListener("click", this._onClick.bind(this));
    this._container.className = labelsContainer;
    if (options === null || options === void 0 ? void 0 : options.onLabelClick)
      this._onClickCallback = options.onLabelClick;
    if (options === null || options === void 0 ? void 0 : options.padding)
      this._padding = options.padding;
    if (options === null || options === void 0 ? void 0 : options.pointerEvents)
      this._pointerEvents = options.pointerEvents;
    if (options === null || options === void 0 ? void 0 : options.dispatchWheelEventElement) {
      this._dispatchWheelEventElement = options.dispatchWheelEventElement;
      this._container.addEventListener("wheel", this._onWheel.bind(this));
    }
  }
  setLabels(labels) {
    const labelsToDelete = new Map(this._cssLabels);
    labels.forEach((label2) => {
      const { x, y, fontSize, color, text, weight, opacity, shouldBeShown, style, className } = label2;
      const exists = this._cssLabels.get(label2.id);
      if (exists) {
        labelsToDelete.delete(label2.id);
      } else {
        const cssLabel = new CssLabel(this._container, label2.text);
        this._cssLabels.set(label2.id, cssLabel);
        this._elementToData.set(cssLabel.element, label2);
      }
      const labelToUpdate = this._cssLabels.get(label2.id);
      if (labelToUpdate) {
        labelToUpdate.setText(text);
        labelToUpdate.setPosition(x, y);
        if (style !== void 0)
          labelToUpdate.setStyle(style);
        if (weight !== void 0)
          labelToUpdate.setWeight(weight);
        if (fontSize !== void 0)
          labelToUpdate.setFontSize(fontSize);
        if (color !== void 0)
          labelToUpdate.setColor(color);
        if (this._padding !== void 0)
          labelToUpdate.setPadding(this._padding);
        if (this._pointerEvents !== void 0)
          labelToUpdate.setPointerEvents(this._pointerEvents);
        if (opacity !== void 0)
          labelToUpdate.setOpacity(opacity);
        if (shouldBeShown !== void 0)
          labelToUpdate.setForceShow(shouldBeShown);
        if (className !== void 0)
          labelToUpdate.setClassName(className);
      }
    });
    for (const [key] of labelsToDelete) {
      const cssLabel = this._cssLabels.get(key);
      if (cssLabel) {
        this._elementToData.delete(cssLabel.element);
        cssLabel.destroy();
      }
      this._cssLabels.delete(key);
    }
  }
  draw(withIntersection = true) {
    if (withIntersection)
      this._intersectLabels();
    this._cssLabels.forEach((cssLabel) => cssLabel.draw());
  }
  show() {
    this._container.className = labelsContainer;
  }
  hide() {
    this._container.className = `${labelsContainer} ${hidden}`;
  }
  destroy() {
    this._container.removeEventListener("click", this._onClick.bind(this));
    this._container.removeEventListener("wheel", this._onWheel.bind(this));
    this._cssLabels.forEach((cssLabel) => cssLabel.destroy());
  }
  _onClick(e) {
    var _a;
    const label2 = this._elementToData.get(e.target);
    if (label2) {
      (_a = this._onClickCallback) === null || _a === void 0 ? void 0 : _a.call(this, e, label2);
    }
  }
  _onWheel(e) {
    var _a;
    e.preventDefault();
    const newWheelEvent = new WheelEvent("wheel", e);
    (_a = this._dispatchWheelEventElement) === null || _a === void 0 ? void 0 : _a.dispatchEvent(newWheelEvent);
  }
  _intersectLabels() {
    const cssLabels = Array.from(this._cssLabels.values());
    cssLabels.forEach((l) => l.setVisibility(l.isOnScreen()));
    for (let i = 0; i < cssLabels.length; i += 1) {
      const label1 = cssLabels[i];
      if (!label1.getVisibility())
        continue;
      for (let j = i + 1; j < cssLabels.length; j += 1) {
        const label2 = cssLabels[j];
        if (!label2.getVisibility())
          continue;
        const isOverlapping = label1.overlaps(label2);
        if (isOverlapping) {
          if (label2.getWeight() > label1.getWeight()) {
            label1.setVisibility(label2.getForceShow() ? false : label1.getForceShow());
          } else {
            label2.setVisibility(label1.getForceShow() ? false : label2.getForceShow());
          }
          continue;
        }
      }
    }
  }
};

export {
  CssLabel,
  LabelRenderer
};
//# sourceMappingURL=chunk-3NUH4VZ6.js.map
