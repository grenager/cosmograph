{
  "version": 3,
  "sources": ["../../crossfilter2/src/array.js", "../../crossfilter2/src/filter.js", "../../crossfilter2/src/identity.js", "../../crossfilter2/src/null.js", "../../crossfilter2/src/zero.js", "../../crossfilter2/src/heap.js", "../../crossfilter2/src/heapselect.js", "../../crossfilter2/src/bisect.js", "../../crossfilter2/src/permute.js", "../../crossfilter2/src/reduce.js", "../../@ranfdev/deepobj/index.js", "../../crossfilter2/src/result.js", "../../crossfilter2/src/index.js"],
  "sourcesContent": ["let array8 = arrayUntyped,\n    array16 = arrayUntyped,\n    array32 = arrayUntyped,\n    arrayLengthen = arrayLengthenUntyped,\n    arrayWiden = arrayWidenUntyped;\nif (typeof Uint8Array !== \"undefined\") {\n  array8 = function(n) { return new Uint8Array(n); };\n  array16 = function(n) { return new Uint16Array(n); };\n  array32 = function(n) { return new Uint32Array(n); };\n\n  arrayLengthen = function(array, length) {\n    if (array.length >= length) return array;\n    var copy = new array.constructor(length);\n    copy.set(array);\n    return copy;\n  };\n\n  arrayWiden = function(array, width) {\n    var copy;\n    switch (width) {\n      case 16: copy = array16(array.length); break;\n      case 32: copy = array32(array.length); break;\n      default: throw new Error(\"invalid array width!\");\n    }\n    copy.set(array);\n    return copy;\n  };\n}\n\nfunction arrayUntyped(n) {\n  var array = new Array(n), i = -1;\n  while (++i < n) array[i] = 0;\n  return array;\n}\n\nfunction arrayLengthenUntyped(array, length) {\n  var n = array.length;\n  while (n < length) array[n++] = 0;\n  return array;\n}\n\nfunction arrayWidenUntyped(array, width) {\n  if (width > 32) throw new Error(\"invalid array width!\");\n  return array;\n}\n\n// An arbitrarily-wide array of bitmasks\nfunction bitarray(n) {\n  this.length = n;\n  this.subarrays = 1;\n  this.width = 8;\n  this.masks = {\n    0: 0\n  }\n\n  this[0] = array8(n);\n}\n\nbitarray.prototype.lengthen = function(n) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    this[i] = arrayLengthen(this[i], n);\n  }\n  this.length = n;\n};\n\n// Reserve a new bit index in the array, returns {offset, one}\nbitarray.prototype.add = function() {\n  var m, w, one, i, len;\n\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    m = this.masks[i];\n    w = this.width - (32 * i);\n    // isolate the rightmost zero bit and return it as an unsigned int of 32 bits, if NaN or -1, return a 0 \n    one = (~m & (m + 1)) >>> 0;\n\n    if (w >= 32 && !one) {\n      continue;\n    }\n\n    if (w < 32 && (one & (1 << w))) {\n      // widen this subarray\n      this[i] = arrayWiden(this[i], w <<= 1);\n      this.width = 32 * i + w;\n    }\n\n    this.masks[i] |= one;\n\n    return {\n      offset: i,\n      one: one\n    };\n  }\n\n  // add a new subarray\n  this[this.subarrays] = array8(this.length);\n  this.masks[this.subarrays] = 1;\n  this.width += 8;\n  return {\n    offset: this.subarrays++,\n    one: 1\n  };\n};\n\n// Copy record from index src to index dest\nbitarray.prototype.copy = function(dest, src) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    this[i][dest] = this[i][src];\n  }\n};\n\n// Truncate the array to the given length\nbitarray.prototype.truncate = function(n) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    for (var j = this.length - 1; j >= n; j--) {\n      this[i][j] = 0;\n    }\n  }\n  this.length = n;\n};\n\n// Checks that all bits for the given index are 0\nbitarray.prototype.zero = function(n) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    if (this[i][n]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n// Checks that all bits for the given index are 0 except for possibly one\nbitarray.prototype.zeroExcept = function(n, offset, zero) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    if (i === offset ? this[i][n] & zero : this[i][n]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n// Checks that all bits for the given index are 0 except for the specified mask.\n// The mask should be an array of the same size as the filter subarrays width.\nbitarray.prototype.zeroExceptMask = function(n, mask) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    if (this[i][n] & mask[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// Checks that only the specified bit is set for the given index\nbitarray.prototype.only = function(n, offset, one) {\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    if (this[i][n] != (i === offset ? one : 0)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n// Checks that only the specified bit is set for the given index except for possibly one other\nbitarray.prototype.onlyExcept = function(n, offset, zero, onlyOffset, onlyOne) {\n  var mask;\n  var i, len;\n  for (i = 0, len = this.subarrays; i < len; ++i) {\n    mask = this[i][n];\n    if (i === offset)\n      mask = (mask & zero) >>> 0;\n    if (mask != (i === onlyOffset ? onlyOne : 0)) {\n      return false;\n    }\n  }\n  return true;\n};\n\nexport default {\n  array8: arrayUntyped,\n  array16: arrayUntyped,\n  array32: arrayUntyped,\n  arrayLengthen: arrayLengthenUntyped,\n  arrayWiden: arrayWidenUntyped,\n  bitarray: bitarray\n};\n", "const filterExact = (bisect, value) => {\n  return function(values) {\n    var n = values.length;\n    return [bisect.left(values, value, 0, n), bisect.right(values, value, 0, n)];\n  };\n}\n\nconst filterRange = (bisect, range) => {\n  var min = range[0],\n      max = range[1];\n  return function(values) {\n    var n = values.length;\n    return [bisect.left(values, min, 0, n), bisect.left(values, max, 0, n)];\n  };\n}\n\nconst filterAll = values => {\n  return [0, values.length];\n}\n\nexport default {\n  filterExact,\n  filterRange,\n  filterAll\n};\n", "export default d => {\n  return d;\n};\n", "export default () =>  {\n  return null;\n}\n", "export default () => {\n  return 0;\n}\n", "import identity from './identity';\n\nfunction heap_by(f) {\n\n  // Builds a binary heap within the specified array a[lo:hi]. The heap has the\n  // property such that the parent a[lo+i] is always less than or equal to its\n  // two children: a[lo+2*i+1] and a[lo+2*i+2].\n  function heap(a, lo, hi) {\n    var n = hi - lo,\n        i = (n >>> 1) + 1;\n    while (--i > 0) sift(a, i, n, lo);\n    return a;\n  }\n\n  // Sorts the specified array a[lo:hi] in descending order, assuming it is\n  // already a heap.\n  function sort(a, lo, hi) {\n    var n = hi - lo,\n        t;\n    while (--n > 0) t = a[lo], a[lo] = a[lo + n], a[lo + n] = t, sift(a, 1, n, lo);\n    return a;\n  }\n\n  // Sifts the element a[lo+i-1] down the heap, where the heap is the contiguous\n  // slice of array a[lo:lo+n]. This method can also be used to update the heap\n  // incrementally, without incurring the full cost of reconstructing the heap.\n  function sift(a, i, n, lo) {\n    var d = a[--lo + i],\n        x = f(d),\n        child;\n    while ((child = i << 1) <= n) {\n      if (child < n && f(a[lo + child]) > f(a[lo + child + 1])) child++;\n      if (x <= f(a[lo + child])) break;\n      a[lo + i] = a[lo + child];\n      i = child;\n    }\n    a[lo + i] = d;\n  }\n\n  heap.sort = sort;\n  return heap;\n}\n\nconst h = heap_by(identity);\nh.by = heap_by;\n\nexport default h;\n", "import identity from './identity';\nimport xFilterHeap from './heap';\n\nfunction heapselect_by(f) {\n  var heap = xFilterHeap.by(f);\n\n  // Returns a new array containing the top k elements in the array a[lo:hi].\n  // The returned array is not sorted, but maintains the heap property. If k is\n  // greater than hi - lo, then fewer than k elements will be returned. The\n  // order of elements in a is unchanged by this operation.\n  function heapselect(a, lo, hi, k) {\n    var queue = new Array(k = Math.min(hi - lo, k)),\n        min,\n        i,\n        d;\n\n    for (i = 0; i < k; ++i) queue[i] = a[lo++];\n    heap(queue, 0, k);\n\n    if (lo < hi) {\n      min = f(queue[0]);\n      do {\n        if (f(d = a[lo]) > min) {\n          queue[0] = d;\n          min = f(heap(queue, 0, k)[0]);\n        }\n      } while (++lo < hi);\n    }\n\n    return queue;\n  }\n\n  return heapselect;\n}\n\n\nconst h = heapselect_by(identity);\nh.by = heapselect_by; // assign the raw function to the export as well\n\nexport default h;\n", "import identity from './identity';\n\nfunction bisect_by(f) {\n\n  // Locate the insertion point for x in a to maintain sorted order. The\n  // arguments lo and hi may be used to specify a subset of the array which\n  // should be considered; by default the entire array is used. If x is already\n  // present in a, the insertion point will be before (to the left of) any\n  // existing entries. The return value is suitable for use as the first\n  // argument to `array.splice` assuming that a is already sorted.\n  //\n  // The returned insertion point i partitions the array a into two halves so\n  // that all v < x for v in a[lo:i] for the left side and all v >= x for v in\n  // a[i:hi] for the right side.\n  function bisectLeft(a, x, lo, hi) {\n    while (lo < hi) {\n      var mid = lo + hi >>> 1;\n      if (f(a[mid]) < x) lo = mid + 1;\n      else hi = mid;\n    }\n    return lo;\n  }\n\n  // Similar to bisectLeft, but returns an insertion point which comes after (to\n  // the right of) any existing entries of x in a.\n  //\n  // The returned insertion point i partitions the array into two halves so that\n  // all v <= x for v in a[lo:i] for the left side and all v > x for v in\n  // a[i:hi] for the right side.\n  function bisectRight(a, x, lo, hi) {\n    while (lo < hi) {\n      var mid = lo + hi >>> 1;\n      if (x < f(a[mid])) hi = mid;\n      else lo = mid + 1;\n    }\n    return lo;\n  }\n\n  bisectRight.right = bisectRight;\n  bisectRight.left = bisectLeft;\n  return bisectRight;\n}\n\nconst bisect = bisect_by(identity);\nbisect.by = bisect_by; // assign the raw function to the export as well\n\nexport default bisect;\n\n", "export default (array, index, deep) => {\n  for (var i = 0, n = index.length, copy = deep ? JSON.parse(JSON.stringify(array)) : new Array(n); i < n; ++i) {\n    copy[i] = array[index[i]];\n  }\n  return copy;\n}\n", "const reduceIncrement = p => {\n  return p + 1;\n}\n\nconst reduceDecrement = p => {\n  return p - 1;\n}\n\nconst reduceAdd = f => {\n  return function(p, v) {\n    return p + +f(v);\n  };\n}\n\nconst reduceSubtract = f => {\n  return function(p, v) {\n    return p - f(v);\n  };\n}\n\nexport default {\n  reduceIncrement,\n  reduceDecrement,\n  reduceAdd,\n  reduceSubtract\n};\n", "export default (action, obj, keys, id, key) => {\n  keys = keys.split(\".\");\n  id = keys.splice(-1, 1);\n  for (key in keys) obj = obj[keys[key]] = obj[keys[key]] || {};\n  return action(obj, id);\n}\n", "import deep from \"@ranfdev/deepobj\"\n// Note(cg): result was previsouly using lodash.result, not ESM compatible.\n \nconst get = (obj, prop) => {\n  const value = obj[prop];\n  return (typeof value === 'function') ? value.call(obj) : value;\n}\n\n/**\n * get value of object at a deep path.\n * if the resolved value is a function,\n * it's invoked with the `this` binding of \n * its parent object and its result is returned. \n *  \n * @param  {Object} obj  the object (e.g. { 'a': [{ 'b': { 'c1': 3, 'c2': 4} }], 'd': {e:1} }; )\n * @param  {String} path deep path (e.g. `d.e`` or `a[0].b.c1`. Dot notation (a.0.b)is also supported)\n * @return {Any}      the resolved value\n */\nconst reg = /\\[([\\w\\d]+)\\]/g;\nexport default (obj, path) => {\n  return deep(get, obj, path.replace(reg, '.$1'))\n}\n", "import xfilterArray from './array';\nimport xfilterFilter from './filter';\nimport cr_identity from './identity';\nimport cr_null from './null';\nimport cr_zero from './zero';\nimport xfilterHeapselect from './heapselect';\nimport xfilterHeap from './heap';\nimport bisect from './bisect';\nimport permute from './permute';\nimport xfilterReduce from './reduce';\nimport result from './result';\n\n// constants\nvar REMOVED_INDEX = -1;\n\ncrossfilter.heap = xfilterHeap;\ncrossfilter.heapselect = xfilterHeapselect;\ncrossfilter.bisect = bisect;\ncrossfilter.permute = permute;\nexport default crossfilter;\n\nfunction crossfilter() {\n  var crossfilter = {\n    add: add,\n    remove: removeData,\n    dimension: dimension,\n    groupAll: groupAll,\n    size: size,\n    all: all,\n    allFiltered: allFiltered,\n    onChange: onChange,\n    isElementFiltered: isElementFiltered\n  };\n\n  var data = [], // the records\n      n = 0, // the number of records; data.length\n      filters, // 1 is filtered out\n      filterListeners = [], // when the filters change\n      dataListeners = [], // when data is added\n      removeDataListeners = [], // when data is removed\n      callbacks = [];\n\n  filters = new xfilterArray.bitarray(0);\n\n  // Adds the specified new records to this crossfilter.\n  function add(newData) {\n    var n0 = n,\n        n1 = newData.length;\n\n    // If there's actually new data to add…\n    // Merge the new data into the existing data.\n    // Lengthen the filter bitset to handle the new records.\n    // Notify listeners (dimensions and groups) that new data is available.\n    if (n1) {\n      data = data.concat(newData);\n      filters.lengthen(n += n1);\n      dataListeners.forEach(function(l) { l(newData, n0, n1); });\n      triggerOnChange('dataAdded');\n    }\n\n    return crossfilter;\n  }\n\n  // Removes all records that match the current filters, or if a predicate function is passed,\n  // removes all records matching the predicate (ignoring filters).\n  function removeData(predicate) {\n    var // Mapping from old record indexes to new indexes (after records removed)\n        newIndex = new Array(n),\n        removed = [],\n        usePred = typeof predicate === 'function',\n        shouldRemove = function (i) {\n          return usePred ? predicate(data[i], i) : filters.zero(i)\n        };\n\n    for (var index1 = 0, index2 = 0; index1 < n; ++index1) {\n      if ( shouldRemove(index1) ) {\n        removed.push(index1);\n        newIndex[index1] = REMOVED_INDEX;\n      } else {\n        newIndex[index1] = index2++;\n      }\n    }\n\n    // Remove all matching records from groups.\n    filterListeners.forEach(function(l) { l(-1, -1, [], removed, true); });\n\n    // Update indexes.\n    removeDataListeners.forEach(function(l) { l(newIndex); });\n\n    // Remove old filters and data by overwriting.\n    for (var index3 = 0, index4 = 0; index3 < n; ++index3) {\n      if ( newIndex[index3] !== REMOVED_INDEX ) {\n        if (index3 !== index4) filters.copy(index4, index3), data[index4] = data[index3];\n        ++index4;\n      }\n    }\n\n    data.length = n = index4;\n    filters.truncate(index4);\n    triggerOnChange('dataRemoved');\n  }\n\n  function maskForDimensions(dimensions) {\n    var n,\n        d,\n        len,\n        id,\n        mask = Array(filters.subarrays);\n    for (n = 0; n < filters.subarrays; n++) { mask[n] = ~0; }\n    for (d = 0, len = dimensions.length; d < len; d++) {\n      // The top bits of the ID are the subarray offset and the lower bits are the bit\n      // offset of the \"one\" mask.\n      id = dimensions[d].id();\n      mask[id >> 7] &= ~(0x1 << (id & 0x3f));\n    }\n    return mask;\n  }\n\n  // Return true if the data element at index i is filtered IN.\n  // Optionally, ignore the filters of any dimensions in the ignore_dimensions list.\n  function isElementFiltered(i, ignore_dimensions) {\n    var mask = maskForDimensions(ignore_dimensions || []);\n    return filters.zeroExceptMask(i,mask);\n  }\n\n  // Adds a new dimension with the specified value accessor function.\n  function dimension(value, iterable) {\n\n    if (typeof value === 'string') {\n      var accessorPath = value;\n      value = function(d) { return result(d, accessorPath); };\n    }\n\n    var dimension = {\n      filter: filter,\n      filterExact: filterExact,\n      filterRange: filterRange,\n      filterFunction: filterFunction,\n      filterAll: filterAll,\n      currentFilter: currentFilter,\n      hasCurrentFilter: hasCurrentFilter,\n      top: top,\n      bottom: bottom,\n      group: group,\n      groupAll: groupAll,\n      dispose: dispose,\n      remove: dispose, // for backwards-compatibility\n      accessor: value,\n      id: function() { return id; }\n    };\n\n    var one, // lowest unset bit as mask, e.g., 00001000\n        zero, // inverted one, e.g., 11110111\n        offset, // offset into the filters arrays\n        id, // unique ID for this dimension (reused when dimensions are disposed)\n        values, // sorted, cached array\n        index, // maps sorted value index -> record index (in data)\n        newValues, // temporary array storing newly-added values\n        newIndex, // temporary array storing newly-added index\n        iterablesIndexCount,\n        iterablesIndexFilterStatus,\n        iterablesEmptyRows = [],\n        sortRange = function(n) {\n          return cr_range(n).sort(function(A, B) {\n            var a = newValues[A], b = newValues[B];\n            return a < b ? -1 : a > b ? 1 : A - B;\n          });\n        },\n        refilter = xfilterFilter.filterAll, // for recomputing filter\n        refilterFunction, // the custom filter function in use\n        filterValue, // the value used for filtering (value, array, function or undefined)\n        filterValuePresent, // true if filterValue contains something\n        indexListeners = [], // when data is added\n        dimensionGroups = [],\n        lo0 = 0,\n        hi0 = 0,\n        t = 0,\n        k;\n\n    // Updating a dimension is a two-stage process. First, we must update the\n    // associated filters for the newly-added records. Once all dimensions have\n    // updated their filters, the groups are notified to update.\n    dataListeners.unshift(preAdd);\n    dataListeners.push(postAdd);\n\n    removeDataListeners.push(removeData);\n\n    // Add a new dimension in the filter bitmap and store the offset and bitmask.\n    var tmp = filters.add();\n    offset = tmp.offset;\n    one = tmp.one;\n    zero = ~one;\n\n    // Create a unique ID for the dimension\n    // IDs will be re-used if dimensions are disposed.\n    // For internal use the ID is the subarray offset shifted left 7 bits or'd with the\n    // bit offset of the set bit in the dimension's \"one\" mask.\n    id = (offset << 7) | (Math.log(one) / Math.log(2));\n\n    preAdd(data, 0, n);\n    postAdd(data, 0, n);\n\n    // Incorporates the specified new records into this dimension.\n    // This function is responsible for updating filters, values, and index.\n    function preAdd(newData, n0, n1) {\n      var newIterablesIndexCount,\n          newIterablesIndexFilterStatus;\n\n      if (iterable){\n        // Count all the values\n        t = 0;\n        j = 0;\n        k = [];\n\n        for (var i0 = 0; i0 < newData.length; i0++) {\n          for(j = 0, k = value(newData[i0]); j < k.length; j++) {\n            t++;\n          }\n        }\n\n        newValues = [];\n        newIterablesIndexCount = cr_range(newData.length);\n        newIterablesIndexFilterStatus = cr_index(t,1);\n        var unsortedIndex = cr_range(t);\n\n        for (var l = 0, index1 = 0; index1 < newData.length; index1++) {\n          k = value(newData[index1])\n          //\n          if(!k.length){\n            newIterablesIndexCount[index1] = 0;\n            iterablesEmptyRows.push(index1 + n0);\n            continue;\n          }\n          newIterablesIndexCount[index1] = k.length\n          for (j = 0; j < k.length; j++) {\n            newValues.push(k[j]);\n            unsortedIndex[l] = index1;\n            l++;\n          }\n        }\n\n        // Create the Sort map used to sort both the values and the valueToData indices\n        var sortMap = sortRange(t);\n\n        // Use the sortMap to sort the newValues\n        newValues = permute(newValues, sortMap);\n\n\n        // Use the sortMap to sort the unsortedIndex map\n        // newIndex should be a map of sortedValue -> crossfilterData\n        newIndex = permute(unsortedIndex, sortMap)\n\n      } else{\n        // Permute new values into natural order using a standard sorted index.\n        newValues = newData.map(value);\n        newIndex = sortRange(n1);\n        newValues = permute(newValues, newIndex);\n      }\n\n      // Bisect newValues to determine which new records are selected.\n      var bounds = refilter(newValues), lo1 = bounds[0], hi1 = bounds[1];\n\n      var index2, index3, index4;\n      if(iterable) {\n        n1 = t;\n        if (refilterFunction) {\n          for (index2 = 0; index2 < n1; ++index2) {\n            if (!refilterFunction(newValues[index2], index2)) {\n              if(--newIterablesIndexCount[newIndex[index2]] === 0) {\n                filters[offset][newIndex[index2] + n0] |= one;\n              }\n              newIterablesIndexFilterStatus[index2] = 1;\n            }\n          }\n        } else {\n          for (index3 = 0; index3 < lo1; ++index3) {\n            if(--newIterablesIndexCount[newIndex[index3]] === 0) {\n              filters[offset][newIndex[index3] + n0] |= one;\n            }\n            newIterablesIndexFilterStatus[index3] = 1;\n          }\n          for (index4 = hi1; index4 < n1; ++index4) {\n            if(--newIterablesIndexCount[newIndex[index4]] === 0) {\n              filters[offset][newIndex[index4] + n0] |= one;\n            }\n            newIterablesIndexFilterStatus[index4] = 1;\n          }\n        }\n      } else {\n        if (refilterFunction) {\n          for (index2 = 0; index2 < n1; ++index2) {\n            if (!refilterFunction(newValues[index2], index2)) {\n              filters[offset][newIndex[index2] + n0] |= one;\n            }\n          }\n        } else {\n          for (index3 = 0; index3 < lo1; ++index3) {\n            filters[offset][newIndex[index3] + n0] |= one;\n          }\n          for (index4 = hi1; index4 < n1; ++index4) {\n            filters[offset][newIndex[index4] + n0] |= one;\n          }\n        }\n      }\n\n      // If this dimension previously had no data, then we don't need to do the\n      // more expensive merge operation; use the new values and index as-is.\n      if (!n0) {\n        values = newValues;\n        index = newIndex;\n        iterablesIndexCount = newIterablesIndexCount;\n        iterablesIndexFilterStatus = newIterablesIndexFilterStatus;\n        lo0 = lo1;\n        hi0 = hi1;\n        return;\n      }\n\n\n\n      var oldValues = values,\n        oldIndex = index,\n        oldIterablesIndexFilterStatus = iterablesIndexFilterStatus,\n        old_n0,\n        i1 = 0;\n\n      i0 = 0;\n\n      if(iterable){\n        old_n0 = n0\n        n0 = oldValues.length;\n        n1 = t\n      }\n\n      // Otherwise, create new arrays into which to merge new and old.\n      values = iterable ? new Array(n0 + n1) : new Array(n);\n      index = iterable ? new Array(n0 + n1) : cr_index(n, n);\n      if(iterable) iterablesIndexFilterStatus = cr_index(n0 + n1, 1);\n\n      // Concatenate the newIterablesIndexCount onto the old one.\n      if(iterable) {\n        var oldiiclength = iterablesIndexCount.length;\n        iterablesIndexCount = xfilterArray.arrayLengthen(iterablesIndexCount, n);\n        for(var j=0; j+oldiiclength < n; j++) {\n          iterablesIndexCount[j+oldiiclength] = newIterablesIndexCount[j];\n        }\n      }\n\n      // Merge the old and new sorted values, and old and new index.\n      var index5 = 0;\n      for (; i0 < n0 && i1 < n1; ++index5) {\n        if (oldValues[i0] < newValues[i1]) {\n          values[index5] = oldValues[i0];\n          if(iterable) iterablesIndexFilterStatus[index5] = oldIterablesIndexFilterStatus[i0];\n          index[index5] = oldIndex[i0++];\n        } else {\n          values[index5] = newValues[i1];\n          if(iterable) iterablesIndexFilterStatus[index5] = newIterablesIndexFilterStatus[i1];\n          index[index5] = newIndex[i1++] + (iterable ? old_n0 : n0);\n        }\n      }\n\n      // Add any remaining old values.\n      for (; i0 < n0; ++i0, ++index5) {\n        values[index5] = oldValues[i0];\n        if(iterable) iterablesIndexFilterStatus[index5] = oldIterablesIndexFilterStatus[i0];\n        index[index5] = oldIndex[i0];\n      }\n\n      // Add any remaining new values.\n      for (; i1 < n1; ++i1, ++index5) {\n        values[index5] = newValues[i1];\n        if(iterable) iterablesIndexFilterStatus[index5] = newIterablesIndexFilterStatus[i1];\n        index[index5] = newIndex[i1] + (iterable ? old_n0 : n0);\n      }\n\n      // Bisect again to recompute lo0 and hi0.\n      bounds = refilter(values), lo0 = bounds[0], hi0 = bounds[1];\n    }\n\n    // When all filters have updated, notify index listeners of the new values.\n    function postAdd(newData, n0, n1) {\n      indexListeners.forEach(function(l) { l(newValues, newIndex, n0, n1); });\n      newValues = newIndex = null;\n    }\n\n    function removeData(reIndex) {\n      if (iterable) {\n        for (var i0 = 0, i1 = 0; i0 < iterablesEmptyRows.length; i0++) {\n          if (reIndex[iterablesEmptyRows[i0]] !== REMOVED_INDEX) {\n            iterablesEmptyRows[i1] = reIndex[iterablesEmptyRows[i0]];\n            i1++;\n          }\n        }\n        iterablesEmptyRows.length = i1;\n        for (i0 = 0, i1 = 0; i0 < n; i0++) {\n          if (reIndex[i0] !== REMOVED_INDEX) {\n            if (i1 !== i0) iterablesIndexCount[i1] = iterablesIndexCount[i0];\n            i1++;\n          }\n        }\n        iterablesIndexCount = iterablesIndexCount.slice(0, i1);\n      }\n      // Rewrite our index, overwriting removed values\n      var n0 = values.length;\n      for (var i = 0, j = 0, oldDataIndex; i < n0; ++i) {\n        oldDataIndex = index[i];\n        if (reIndex[oldDataIndex] !== REMOVED_INDEX) {\n          if (i !== j) values[j] = values[i];\n          index[j] = reIndex[oldDataIndex];\n          if (iterable) {\n            iterablesIndexFilterStatus[j] = iterablesIndexFilterStatus[i];\n          }\n          ++j;\n        }\n      }\n      values.length = j;\n      if (iterable) iterablesIndexFilterStatus = iterablesIndexFilterStatus.slice(0, j);\n      while (j < n0) index[j++] = 0;\n\n      // Bisect again to recompute lo0 and hi0.\n      var bounds = refilter(values);\n      lo0 = bounds[0], hi0 = bounds[1];\n    }\n\n    // Updates the selected values based on the specified bounds [lo, hi].\n    // This implementation is used by all the public filter methods.\n    function filterIndexBounds(bounds) {\n\n      var lo1 = bounds[0],\n          hi1 = bounds[1];\n\n      if (refilterFunction) {\n        refilterFunction = null;\n        filterIndexFunction(function(d, i) { return lo1 <= i && i < hi1; }, bounds[0] === 0 && bounds[1] === values.length);\n        lo0 = lo1;\n        hi0 = hi1;\n        return dimension;\n      }\n\n      var i,\n          j,\n          k,\n          added = [],\n          removed = [],\n          valueIndexAdded = [],\n          valueIndexRemoved = [];\n\n\n      // Fast incremental update based on previous lo index.\n      if (lo1 < lo0) {\n        for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {\n          added.push(index[i]);\n          valueIndexAdded.push(i);\n        }\n      } else if (lo1 > lo0) {\n        for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {\n          removed.push(index[i]);\n          valueIndexRemoved.push(i);\n        }\n      }\n\n      // Fast incremental update based on previous hi index.\n      if (hi1 > hi0) {\n        for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {\n          added.push(index[i]);\n          valueIndexAdded.push(i);\n        }\n      } else if (hi1 < hi0) {\n        for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {\n          removed.push(index[i]);\n          valueIndexRemoved.push(i);\n        }\n      }\n\n      if(!iterable) {\n        // Flip filters normally.\n\n        for(i=0; i<added.length; i++) {\n          filters[offset][added[i]] ^= one;\n        }\n\n        for(i=0; i<removed.length; i++) {\n          filters[offset][removed[i]] ^= one;\n        }\n\n      } else {\n        // For iterables, we need to figure out if the row has been completely removed vs partially included\n        // Only count a row as added if it is not already being aggregated. Only count a row\n        // as removed if the last element being aggregated is removed.\n\n        var newAdded = [];\n        var newRemoved = [];\n        for (i = 0; i < added.length; i++) {\n          iterablesIndexCount[added[i]]++\n          iterablesIndexFilterStatus[valueIndexAdded[i]] = 0;\n          if(iterablesIndexCount[added[i]] === 1) {\n            filters[offset][added[i]] ^= one;\n            newAdded.push(added[i]);\n          }\n        }\n        for (i = 0; i < removed.length; i++) {\n          iterablesIndexCount[removed[i]]--\n          iterablesIndexFilterStatus[valueIndexRemoved[i]] = 1;\n          if(iterablesIndexCount[removed[i]] === 0) {\n            filters[offset][removed[i]] ^= one;\n            newRemoved.push(removed[i]);\n          }\n        }\n\n        added = newAdded;\n        removed = newRemoved;\n\n        // Now handle empty rows.\n        if(refilter === xfilterFilter.filterAll) {\n          for(i = 0; i < iterablesEmptyRows.length; i++) {\n            if((filters[offset][k = iterablesEmptyRows[i]] & one)) {\n              // Was not in the filter, so set the filter and add\n              filters[offset][k] ^= one;\n              added.push(k);\n            }\n          }\n        } else {\n          // filter in place - remove empty rows if necessary\n          for(i = 0; i < iterablesEmptyRows.length; i++) {\n            if(!(filters[offset][k = iterablesEmptyRows[i]] & one)) {\n              // Was in the filter, so set the filter and remove\n              filters[offset][k] ^= one;\n              removed.push(k);\n            }\n          }\n        }\n      }\n\n      lo0 = lo1;\n      hi0 = hi1;\n      filterListeners.forEach(function(l) { l(one, offset, added, removed); });\n      triggerOnChange('filtered');\n      return dimension;\n    }\n\n    // Filters this dimension using the specified range, value, or null.\n    // If the range is null, this is equivalent to filterAll.\n    // If the range is an array, this is equivalent to filterRange.\n    // Otherwise, this is equivalent to filterExact.\n    function filter(range) {\n      return range == null\n          ? filterAll() : Array.isArray(range)\n          ? filterRange(range) : typeof range === \"function\"\n          ? filterFunction(range)\n          : filterExact(range);\n    }\n\n    // Filters this dimension to select the exact value.\n    function filterExact(value) {\n      filterValue = value;\n      filterValuePresent = true;\n      return filterIndexBounds((refilter = xfilterFilter.filterExact(bisect, value))(values));\n    }\n\n    // Filters this dimension to select the specified range [lo, hi].\n    // The lower bound is inclusive, and the upper bound is exclusive.\n    function filterRange(range) {\n      filterValue = range;\n      filterValuePresent = true;\n      return filterIndexBounds((refilter = xfilterFilter.filterRange(bisect, range))(values));\n    }\n\n    // Clears any filters on this dimension.\n    function filterAll() {\n      filterValue = undefined;\n      filterValuePresent = false;\n      return filterIndexBounds((refilter = xfilterFilter.filterAll)(values));\n    }\n\n    // Filters this dimension using an arbitrary function.\n    function filterFunction(f) {\n      filterValue = f;\n      filterValuePresent = true;\n\n      refilterFunction = f;\n      refilter = xfilterFilter.filterAll;\n\n      filterIndexFunction(f, false);\n\n      var bounds = refilter(values);\n      lo0 = bounds[0], hi0 = bounds[1];\n\n      return dimension;\n    }\n\n    function filterIndexFunction(f, filterAll) {\n      var i,\n          k,\n          x,\n          added = [],\n          removed = [],\n          valueIndexAdded = [],\n          valueIndexRemoved = [],\n          indexLength = values.length;\n\n      if(!iterable) {\n        for (i = 0; i < indexLength; ++i) {\n          if (!(filters[offset][k = index[i]] & one) ^ !!(x = f(values[i], i))) {\n            if (x) added.push(k);\n            else removed.push(k);\n          }\n        }\n      }\n\n      if(iterable) {\n        for(i=0; i < indexLength; ++i) {\n          if(f(values[i], i)) {\n            added.push(index[i]);\n            valueIndexAdded.push(i);\n          } else {\n            removed.push(index[i]);\n            valueIndexRemoved.push(i);\n          }\n        }\n      }\n\n      if(!iterable) {\n        for(i=0; i<added.length; i++) {\n          if(filters[offset][added[i]] & one) filters[offset][added[i]] &= zero;\n        }\n\n        for(i=0; i<removed.length; i++) {\n          if(!(filters[offset][removed[i]] & one)) filters[offset][removed[i]] |= one;\n        }\n      } else {\n\n        var newAdded = [];\n        var newRemoved = [];\n        for (i = 0; i < added.length; i++) {\n          // First check this particular value needs to be added\n          if(iterablesIndexFilterStatus[valueIndexAdded[i]] === 1) {\n            iterablesIndexCount[added[i]]++\n            iterablesIndexFilterStatus[valueIndexAdded[i]] = 0;\n            if(iterablesIndexCount[added[i]] === 1) {\n              filters[offset][added[i]] ^= one;\n              newAdded.push(added[i]);\n            }\n          }\n        }\n        for (i = 0; i < removed.length; i++) {\n          // First check this particular value needs to be removed\n          if(iterablesIndexFilterStatus[valueIndexRemoved[i]] === 0) {\n            iterablesIndexCount[removed[i]]--\n            iterablesIndexFilterStatus[valueIndexRemoved[i]] = 1;\n            if(iterablesIndexCount[removed[i]] === 0) {\n              filters[offset][removed[i]] ^= one;\n              newRemoved.push(removed[i]);\n            }\n          }\n        }\n\n        added = newAdded;\n        removed = newRemoved;\n\n        // Now handle empty rows.\n        if(filterAll) {\n          for(i = 0; i < iterablesEmptyRows.length; i++) {\n            if((filters[offset][k = iterablesEmptyRows[i]] & one)) {\n              // Was not in the filter, so set the filter and add\n              filters[offset][k] ^= one;\n              added.push(k);\n            }\n          }\n        } else {\n          // filter in place - remove empty rows if necessary\n          for(i = 0; i < iterablesEmptyRows.length; i++) {\n            if(!(filters[offset][k = iterablesEmptyRows[i]] & one)) {\n              // Was in the filter, so set the filter and remove\n              filters[offset][k] ^= one;\n              removed.push(k);\n            }\n          }\n        }\n      }\n\n      filterListeners.forEach(function(l) { l(one, offset, added, removed); });\n      triggerOnChange('filtered');\n    }\n\n    function currentFilter() {\n      return filterValue;\n    }\n\n    function hasCurrentFilter() {\n      return filterValuePresent;\n    }\n\n    // Returns the top K selected records based on this dimension's order.\n    // Note: observes this dimension's filter, unlike group and groupAll.\n    function top(k, top_offset) {\n      var array = [],\n          i = hi0,\n          j,\n          toSkip = 0;\n\n      if(top_offset && top_offset > 0) toSkip = top_offset;\n\n      while (--i >= lo0 && k > 0) {\n        if (filters.zero(j = index[i])) {\n          if(toSkip > 0) {\n            //skip matching row\n            --toSkip;\n          } else {\n            array.push(data[j]);\n            --k;\n          }\n        }\n      }\n\n      if(iterable){\n        for(i = 0; i < iterablesEmptyRows.length && k > 0; i++) {\n          // Add row with empty iterable column at the end\n          if(filters.zero(j = iterablesEmptyRows[i])) {\n            if(toSkip > 0) {\n              //skip matching row\n              --toSkip;\n            } else {\n              array.push(data[j]);\n              --k;\n            }\n          }\n        }\n      }\n\n      return array;\n    }\n\n    // Returns the bottom K selected records based on this dimension's order.\n    // Note: observes this dimension's filter, unlike group and groupAll.\n    function bottom(k, bottom_offset) {\n      var array = [],\n          i,\n          j,\n          toSkip = 0;\n\n      if(bottom_offset && bottom_offset > 0) toSkip = bottom_offset;\n\n      if(iterable) {\n        // Add row with empty iterable column at the top\n        for(i = 0; i < iterablesEmptyRows.length && k > 0; i++) {\n          if(filters.zero(j = iterablesEmptyRows[i])) {\n            if(toSkip > 0) {\n              //skip matching row\n              --toSkip;\n            } else {\n              array.push(data[j]);\n              --k;\n            }\n          }\n        }\n      }\n\n      i = lo0;\n\n      while (i < hi0 && k > 0) {\n        if (filters.zero(j = index[i])) {\n          if(toSkip > 0) {\n            //skip matching row\n            --toSkip;\n          } else {\n            array.push(data[j]);\n            --k;\n          }\n        }\n        i++;\n      }\n\n      return array;\n    }\n\n    // Adds a new group to this dimension, using the specified key function.\n    function group(key) {\n      var group = {\n        top: top,\n        all: all,\n        reduce: reduce,\n        reduceCount: reduceCount,\n        reduceSum: reduceSum,\n        order: order,\n        orderNatural: orderNatural,\n        size: size,\n        dispose: dispose,\n        remove: dispose // for backwards-compatibility\n      };\n\n      // Ensure that this group will be removed when the dimension is removed.\n      dimensionGroups.push(group);\n\n      var groups, // array of {key, value}\n          groupIndex, // object id ↦ group id\n          groupWidth = 8,\n          groupCapacity = capacity(groupWidth),\n          k = 0, // cardinality\n          select,\n          heap,\n          reduceAdd,\n          reduceRemove,\n          reduceInitial,\n          update = cr_null,\n          reset = cr_null,\n          resetNeeded = true,\n          groupAll = key === cr_null,\n          n0old;\n\n      if (arguments.length < 1) key = cr_identity;\n\n      // The group listens to the crossfilter for when any dimension changes, so\n      // that it can update the associated reduce values. It must also listen to\n      // the parent dimension for when data is added, and compute new keys.\n      filterListeners.push(update);\n      indexListeners.push(add);\n      removeDataListeners.push(removeData);\n\n      // Incorporate any existing data into the grouping.\n      add(values, index, 0, n);\n\n      // Incorporates the specified new values into this group.\n      // This function is responsible for updating groups and groupIndex.\n      function add(newValues, newIndex, n0, n1) {\n\n        if(iterable) {\n          n0old = n0\n          n0 = values.length - newValues.length\n          n1 = newValues.length;\n        }\n\n        var oldGroups = groups,\n            reIndex = iterable ? [] : cr_index(k, groupCapacity),\n            add = reduceAdd,\n            remove = reduceRemove,\n            initial = reduceInitial,\n            k0 = k, // old cardinality\n            i0 = 0, // index of old group\n            i1 = 0, // index of new record\n            j, // object id\n            g0, // old group\n            x0, // old key\n            x1, // new key\n            g, // group to add\n            x; // key of group to add\n\n        // If a reset is needed, we don't need to update the reduce values.\n        if (resetNeeded) add = initial = cr_null;\n        if (resetNeeded) remove = initial = cr_null;\n\n        // Reset the new groups (k is a lower bound).\n        // Also, make sure that groupIndex exists and is long enough.\n        groups = new Array(k), k = 0;\n        if(iterable){\n          groupIndex = k0 ? groupIndex : [];\n        }\n        else{\n          groupIndex = k0 > 1 ? xfilterArray.arrayLengthen(groupIndex, n) : cr_index(n, groupCapacity);\n        }\n\n\n        // Get the first old key (x0 of g0), if it exists.\n        if (k0) x0 = (g0 = oldGroups[0]).key;\n\n        // Find the first new key (x1), skipping NaN keys.\n        while (i1 < n1 && !((x1 = key(newValues[i1])) >= x1)) ++i1;\n\n        // While new keys remain…\n        while (i1 < n1) {\n\n          // Determine the lesser of the two current keys; new and old.\n          // If there are no old keys remaining, then always add the new key.\n          if (g0 && x0 <= x1) {\n            g = g0, x = x0;\n\n            // Record the new index of the old group.\n            reIndex[i0] = k;\n\n            // Retrieve the next old key.\n            g0 = oldGroups[++i0];\n            if (g0) x0 = g0.key;\n          } else {\n            g = {key: x1, value: initial()}, x = x1;\n          }\n\n          // Add the lesser group.\n          groups[k] = g;\n\n          // Add any selected records belonging to the added group, while\n          // advancing the new key and populating the associated group index.\n\n          while (x1 <= x) {\n            j = newIndex[i1] + (iterable ? n0old : n0)\n\n\n            if(iterable){\n              if(groupIndex[j]){\n                groupIndex[j].push(k)\n              }\n              else{\n                groupIndex[j] = [k]\n              }\n            }\n            else{\n              groupIndex[j] = k;\n            }\n\n            // Always add new values to groups. Only remove when not in filter.\n            // This gives groups full information on data life-cycle.\n            g.value = add(g.value, data[j], true);\n            if (!filters.zeroExcept(j, offset, zero)) g.value = remove(g.value, data[j], false);\n            if (++i1 >= n1) break;\n            x1 = key(newValues[i1]);\n          }\n\n          groupIncrement();\n        }\n\n        // Add any remaining old groups that were greater th1an all new keys.\n        // No incremental reduce is needed; these groups have no new records.\n        // Also record the new index of the old group.\n        while (i0 < k0) {\n          groups[reIndex[i0] = k] = oldGroups[i0++];\n          groupIncrement();\n        }\n\n\n        // Fill in gaps with empty arrays where there may have been rows with empty iterables\n        if(iterable){\n          for (var index1 = 0; index1 < n; index1++) {\n            if(!groupIndex[index1]){\n              groupIndex[index1] = [];\n            }\n          }\n        }\n\n        // If we added any new groups before any old groups,\n        // update the group index of all the old records.\n        if(k > i0){\n          if(iterable){\n            for (i0 = 0; i0 < n0old; ++i0) {\n              for (index1 = 0; index1 < groupIndex[i0].length; index1++) {\n                groupIndex[i0][index1] = reIndex[groupIndex[i0][index1]];\n              }\n            }\n          }\n          else{\n            for (i0 = 0; i0 < n0; ++i0) {\n              groupIndex[i0] = reIndex[groupIndex[i0]];\n            }\n          }\n        }\n\n        // Modify the update and reset behavior based on the cardinality.\n        // If the cardinality is less than or equal to one, then the groupIndex\n        // is not needed. If the cardinality is zero, then there are no records\n        // and therefore no groups to update or reset. Note that we also must\n        // change the registered listener to point to the new method.\n        j = filterListeners.indexOf(update);\n        if (k > 1 || iterable) {\n          update = updateMany;\n          reset = resetMany;\n        } else {\n          if (!k && groupAll) {\n            k = 1;\n            groups = [{key: null, value: initial()}];\n          }\n          if (k === 1) {\n            update = updateOne;\n            reset = resetOne;\n          } else {\n            update = cr_null;\n            reset = cr_null;\n          }\n          groupIndex = null;\n        }\n        filterListeners[j] = update;\n\n        // Count the number of added groups,\n        // and widen the group index as needed.\n        function groupIncrement() {\n          if(iterable){\n            k++\n            return\n          }\n          if (++k === groupCapacity) {\n            reIndex = xfilterArray.arrayWiden(reIndex, groupWidth <<= 1);\n            groupIndex = xfilterArray.arrayWiden(groupIndex, groupWidth);\n            groupCapacity = capacity(groupWidth);\n          }\n        }\n      }\n\n      function removeData(reIndex) {\n        if (k > 1 || iterable) {\n          var oldK = k,\n              oldGroups = groups,\n              seenGroups = cr_index(oldK, oldK),\n              i,\n              i0,\n              j;\n\n          // Filter out non-matches by copying matching group index entries to\n          // the beginning of the array.\n          if (!iterable) {\n            for (i = 0, j = 0; i < n; ++i) {\n              if (reIndex[i] !== REMOVED_INDEX) {\n                seenGroups[groupIndex[j] = groupIndex[i]] = 1;\n                ++j;\n              }\n            }\n          } else {\n            for (i = 0, j = 0; i < n; ++i) {\n              if (reIndex[i] !== REMOVED_INDEX) {\n                groupIndex[j] = groupIndex[i];\n                for (i0 = 0; i0 < groupIndex[j].length; i0++) {\n                  seenGroups[groupIndex[j][i0]] = 1;\n                }\n                ++j;\n              }\n            }\n            groupIndex = groupIndex.slice(0, j);\n          }\n\n          // Reassemble groups including only those groups that were referred\n          // to by matching group index entries.  Note the new group index in\n          // seenGroups.\n          groups = [], k = 0;\n          for (i = 0; i < oldK; ++i) {\n            if (seenGroups[i]) {\n              seenGroups[i] = k++;\n              groups.push(oldGroups[i]);\n            }\n          }\n\n          if (k > 1 || iterable) {\n            // Reindex the group index using seenGroups to find the new index.\n            if (!iterable) {\n              for (i = 0; i < j; ++i) groupIndex[i] = seenGroups[groupIndex[i]];\n            } else {\n              for (i = 0; i < j; ++i) {\n                for (i0 = 0; i0 < groupIndex[i].length; ++i0) {\n                  groupIndex[i][i0] = seenGroups[groupIndex[i][i0]];\n                }\n              }\n            }\n          } else {\n            groupIndex = null;\n          }\n          filterListeners[filterListeners.indexOf(update)] = k > 1 || iterable\n              ? (reset = resetMany, update = updateMany)\n              : k === 1 ? (reset = resetOne, update = updateOne)\n              : reset = update = cr_null;\n        } else if (k === 1) {\n          if (groupAll) return;\n          for (var index3 = 0; index3 < n; ++index3) if (reIndex[index3] !== REMOVED_INDEX) return;\n          groups = [], k = 0;\n          filterListeners[filterListeners.indexOf(update)] =\n          update = reset = cr_null;\n        }\n      }\n\n      // Reduces the specified selected or deselected records.\n      // This function is only used when the cardinality is greater than 1.\n      // notFilter indicates a crossfilter.add/remove operation.\n      function updateMany(filterOne, filterOffset, added, removed, notFilter) {\n\n        if ((filterOne === one && filterOffset === offset) || resetNeeded) return;\n\n        var i,\n            j,\n            k,\n            n,\n            g;\n\n        if(iterable){\n          // Add the added values.\n          for (i = 0, n = added.length; i < n; ++i) {\n            if (filters.zeroExcept(k = added[i], offset, zero)) {\n              for (j = 0; j < groupIndex[k].length; j++) {\n                g = groups[groupIndex[k][j]];\n                g.value = reduceAdd(g.value, data[k], false, j);\n              }\n            }\n          }\n\n          // Remove the removed values.\n          for (i = 0, n = removed.length; i < n; ++i) {\n            if (filters.onlyExcept(k = removed[i], offset, zero, filterOffset, filterOne)) {\n              for (j = 0; j < groupIndex[k].length; j++) {\n                g = groups[groupIndex[k][j]];\n                g.value = reduceRemove(g.value, data[k], notFilter, j);\n              }\n            }\n          }\n          return;\n        }\n\n        // Add the added values.\n        for (i = 0, n = added.length; i < n; ++i) {\n          if (filters.zeroExcept(k = added[i], offset, zero)) {\n            g = groups[groupIndex[k]];\n            g.value = reduceAdd(g.value, data[k], false);\n          }\n        }\n\n        // Remove the removed values.\n        for (i = 0, n = removed.length; i < n; ++i) {\n          if (filters.onlyExcept(k = removed[i], offset, zero, filterOffset, filterOne)) {\n            g = groups[groupIndex[k]];\n            g.value = reduceRemove(g.value, data[k], notFilter);\n          }\n        }\n      }\n\n      // Reduces the specified selected or deselected records.\n      // This function is only used when the cardinality is 1.\n      // notFilter indicates a crossfilter.add/remove operation.\n      function updateOne(filterOne, filterOffset, added, removed, notFilter) {\n        if ((filterOne === one && filterOffset === offset) || resetNeeded) return;\n\n        var i,\n            k,\n            n,\n            g = groups[0];\n\n        // Add the added values.\n        for (i = 0, n = added.length; i < n; ++i) {\n          if (filters.zeroExcept(k = added[i], offset, zero)) {\n            g.value = reduceAdd(g.value, data[k], false);\n          }\n        }\n\n        // Remove the removed values.\n        for (i = 0, n = removed.length; i < n; ++i) {\n          if (filters.onlyExcept(k = removed[i], offset, zero, filterOffset, filterOne)) {\n            g.value = reduceRemove(g.value, data[k], notFilter);\n          }\n        }\n      }\n\n      // Recomputes the group reduce values from scratch.\n      // This function is only used when the cardinality is greater than 1.\n      function resetMany() {\n        var i,\n            j,\n            g;\n\n        // Reset all group values.\n        for (i = 0; i < k; ++i) {\n          groups[i].value = reduceInitial();\n        }\n\n        // We add all records and then remove filtered records so that reducers\n        // can build an 'unfiltered' view even if there are already filters in\n        // place on other dimensions.\n        if(iterable){\n          for (i = 0; i < n; ++i) {\n            for (j = 0; j < groupIndex[i].length; j++) {\n              g = groups[groupIndex[i][j]];\n              g.value = reduceAdd(g.value, data[i], true, j);\n            }\n          }\n          for (i = 0; i < n; ++i) {\n            if (!filters.zeroExcept(i, offset, zero)) {\n              for (j = 0; j < groupIndex[i].length; j++) {\n                g = groups[groupIndex[i][j]];\n                g.value = reduceRemove(g.value, data[i], false, j);\n              }\n            }\n          }\n          return;\n        }\n\n        for (i = 0; i < n; ++i) {\n          g = groups[groupIndex[i]];\n          g.value = reduceAdd(g.value, data[i], true);\n        }\n        for (i = 0; i < n; ++i) {\n          if (!filters.zeroExcept(i, offset, zero)) {\n            g = groups[groupIndex[i]];\n            g.value = reduceRemove(g.value, data[i], false);\n          }\n        }\n      }\n\n      // Recomputes the group reduce values from scratch.\n      // This function is only used when the cardinality is 1.\n      function resetOne() {\n        var i,\n            g = groups[0];\n\n        // Reset the singleton group values.\n        g.value = reduceInitial();\n\n        // We add all records and then remove filtered records so that reducers\n        // can build an 'unfiltered' view even if there are already filters in\n        // place on other dimensions.\n        for (i = 0; i < n; ++i) {\n          g.value = reduceAdd(g.value, data[i], true);\n        }\n\n        for (i = 0; i < n; ++i) {\n          if (!filters.zeroExcept(i, offset, zero)) {\n            g.value = reduceRemove(g.value, data[i], false);\n          }\n        }\n      }\n\n      // Returns the array of group values, in the dimension's natural order.\n      function all() {\n        if (resetNeeded) reset(), resetNeeded = false;\n        return groups;\n      }\n\n      // Returns a new array containing the top K group values, in reduce order.\n      function top(k) {\n        var top = select(all(), 0, groups.length, k);\n        return heap.sort(top, 0, top.length);\n      }\n\n      // Sets the reduce behavior for this group to use the specified functions.\n      // This method lazily recomputes the reduce values, waiting until needed.\n      function reduce(add, remove, initial) {\n        reduceAdd = add;\n        reduceRemove = remove;\n        reduceInitial = initial;\n        resetNeeded = true;\n        return group;\n      }\n\n      // A convenience method for reducing by count.\n      function reduceCount() {\n        return reduce(xfilterReduce.reduceIncrement, xfilterReduce.reduceDecrement, cr_zero);\n      }\n\n      // A convenience method for reducing by sum(value).\n      function reduceSum(value) {\n        return reduce(xfilterReduce.reduceAdd(value), xfilterReduce.reduceSubtract(value), cr_zero);\n      }\n\n      // Sets the reduce order, using the specified accessor.\n      function order(value) {\n        select = xfilterHeapselect.by(valueOf);\n        heap = xfilterHeap.by(valueOf);\n        function valueOf(d) { return value(d.value); }\n        return group;\n      }\n\n      // A convenience method for natural ordering by reduce value.\n      function orderNatural() {\n        return order(cr_identity);\n      }\n\n      // Returns the cardinality of this group, irrespective of any filters.\n      function size() {\n        return k;\n      }\n\n      // Removes this group and associated event listeners.\n      function dispose() {\n        var i = filterListeners.indexOf(update);\n        if (i >= 0) filterListeners.splice(i, 1);\n        i = indexListeners.indexOf(add);\n        if (i >= 0) indexListeners.splice(i, 1);\n        i = removeDataListeners.indexOf(removeData);\n        if (i >= 0) removeDataListeners.splice(i, 1);\n        i = dimensionGroups.indexOf(group);\n        if (i >= 0) dimensionGroups.splice(i, 1);\n        return group;\n      }\n\n      return reduceCount().orderNatural();\n    }\n\n    // A convenience function for generating a singleton group.\n    function groupAll() {\n      var g = group(cr_null), all = g.all;\n      delete g.all;\n      delete g.top;\n      delete g.order;\n      delete g.orderNatural;\n      delete g.size;\n      g.value = function() { return all()[0].value; };\n      return g;\n    }\n\n    // Removes this dimension and associated groups and event listeners.\n    function dispose() {\n      dimensionGroups.forEach(function(group) { group.dispose(); });\n      var i = dataListeners.indexOf(preAdd);\n      if (i >= 0) dataListeners.splice(i, 1);\n      i = dataListeners.indexOf(postAdd);\n      if (i >= 0) dataListeners.splice(i, 1);\n      i = removeDataListeners.indexOf(removeData);\n      if (i >= 0) removeDataListeners.splice(i, 1);\n      filters.masks[offset] &= zero;\n      return filterAll();\n    }\n\n    return dimension;\n  }\n\n  // A convenience method for groupAll on a dummy dimension.\n  // This implementation can be optimized since it always has cardinality 1.\n  function groupAll() {\n    var group = {\n      reduce: reduce,\n      reduceCount: reduceCount,\n      reduceSum: reduceSum,\n      value: value,\n      dispose: dispose,\n      remove: dispose // for backwards-compatibility\n    };\n\n    var reduceValue,\n        reduceAdd,\n        reduceRemove,\n        reduceInitial,\n        resetNeeded = true;\n\n    // The group listens to the crossfilter for when any dimension changes, so\n    // that it can update the reduce value. It must also listen to the parent\n    // dimension for when data is added.\n    filterListeners.push(update);\n    dataListeners.push(add);\n\n    // For consistency; actually a no-op since resetNeeded is true.\n    add(data, 0, n);\n\n    // Incorporates the specified new values into this group.\n    function add(newData, n0) {\n      var i;\n\n      if (resetNeeded) return;\n\n      // Cycle through all the values.\n      for (i = n0; i < n; ++i) {\n\n        // Add all values all the time.\n        reduceValue = reduceAdd(reduceValue, data[i], true);\n\n        // Remove the value if filtered.\n        if (!filters.zero(i)) {\n          reduceValue = reduceRemove(reduceValue, data[i], false);\n        }\n      }\n    }\n\n    // Reduces the specified selected or deselected records.\n    function update(filterOne, filterOffset, added, removed, notFilter) {\n      var i,\n          k,\n          n;\n\n      if (resetNeeded) return;\n\n      // Add the added values.\n      for (i = 0, n = added.length; i < n; ++i) {\n        if (filters.zero(k = added[i])) {\n          reduceValue = reduceAdd(reduceValue, data[k], notFilter);\n        }\n      }\n\n      // Remove the removed values.\n      for (i = 0, n = removed.length; i < n; ++i) {\n        if (filters.only(k = removed[i], filterOffset, filterOne)) {\n          reduceValue = reduceRemove(reduceValue, data[k], notFilter);\n        }\n      }\n    }\n\n    // Recomputes the group reduce value from scratch.\n    function reset() {\n      var i;\n\n      reduceValue = reduceInitial();\n\n      // Cycle through all the values.\n      for (i = 0; i < n; ++i) {\n\n        // Add all values all the time.\n        reduceValue = reduceAdd(reduceValue, data[i], true);\n\n        // Remove the value if it is filtered.\n        if (!filters.zero(i)) {\n          reduceValue = reduceRemove(reduceValue, data[i], false);\n        }\n      }\n    }\n\n    // Sets the reduce behavior for this group to use the specified functions.\n    // This method lazily recomputes the reduce value, waiting until needed.\n    function reduce(add, remove, initial) {\n      reduceAdd = add;\n      reduceRemove = remove;\n      reduceInitial = initial;\n      resetNeeded = true;\n      return group;\n    }\n\n    // A convenience method for reducing by count.\n    function reduceCount() {\n      return reduce(xfilterReduce.reduceIncrement, xfilterReduce.reduceDecrement, cr_zero);\n    }\n\n    // A convenience method for reducing by sum(value).\n    function reduceSum(value) {\n      return reduce(xfilterReduce.reduceAdd(value), xfilterReduce.reduceSubtract(value), cr_zero);\n    }\n\n    // Returns the computed reduce value.\n    function value() {\n      if (resetNeeded) reset(), resetNeeded = false;\n      return reduceValue;\n    }\n\n    // Removes this group and associated event listeners.\n    function dispose() {\n      var i = filterListeners.indexOf(update);\n      if (i >= 0) filterListeners.splice(i, 1);\n      i = dataListeners.indexOf(add);\n      if (i >= 0) dataListeners.splice(i, 1);\n      return group;\n    }\n\n    return reduceCount();\n  }\n\n  // Returns the number of records in this crossfilter, irrespective of any filters.\n  function size() {\n    return n;\n  }\n\n  // Returns the raw row data contained in this crossfilter\n  function all(){\n    return data;\n  }\n\n  // Returns row data with all dimension filters applied, except for filters in ignore_dimensions\n  function allFiltered(ignore_dimensions) {\n    var array = [],\n        i = 0,\n        mask = maskForDimensions(ignore_dimensions || []);\n\n      for (i = 0; i < n; i++) {\n        if (filters.zeroExceptMask(i, mask)) {\n          array.push(data[i]);\n        }\n      }\n\n      return array;\n  }\n\n  function onChange(cb){\n    if(typeof cb !== 'function'){\n      /* eslint no-console: 0 */\n      console.warn('onChange callback parameter must be a function!');\n      return;\n    }\n    callbacks.push(cb);\n    return function(){\n      callbacks.splice(callbacks.indexOf(cb), 1);\n    };\n  }\n\n  function triggerOnChange(eventName){\n    for (var i = 0; i < callbacks.length; i++) {\n      callbacks[i](eventName);\n    }\n  }\n\n  return arguments.length\n      ? add(arguments[0])\n      : crossfilter;\n}\n\n// Returns an array of size n, big enough to store ids up to m.\nfunction cr_index(n, m) {\n  return (m < 0x101\n      ? xfilterArray.array8 : m < 0x10001\n      ? xfilterArray.array16\n      : xfilterArray.array32)(n);\n}\n\n// Constructs a new array of size n, with sequential values from 0 to n - 1.\nfunction cr_range(n) {\n  var range = cr_index(n, n);\n  for (var i = -1; ++i < n;) range[i] = i;\n  return range;\n}\n\nfunction capacity(w) {\n  return w === 8\n      ? 0x100 : w === 16\n      ? 0x10000\n      : 0x100000000;\n}\n"],
  "mappings": "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",
  "names": ["bisect", "h", "action", "obj", "keys", "id", "key", "split", "splice", "crossfilter", "n", "dimension", "filterExact", "filterRange", "filterAll", "groupAll", "removeData", "i", "k", "value", "group", "top", "all", "size", "dispose", "reduceAdd", "add", "newValues", "newIndex"]
}
